# 应用设计文档

## 文档信息

| 项目 | 内容 |
|-----|------|
| 文档名称 | OpenRecommend 应用设计文档 |
| 版本 | 1.0.0 |
| 编写日期 | 2026-02-15 |
| 项目名称 | 多内容类型智能推荐系统 |

---

## 一、应用架构

### 1.1 架构模式

采用**分层架构 + 模块化设计**的单体应用架构：

```
┌─────────────────────────────────────────────────────────┐
│                    表现层 (Presentation)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ Controller   │  │ Filter       │  │ Interceptor  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                   业务层 (Service)                         │
│  ┌────────────────────────────────────────────────────┐ │
│  │              推荐引擎模块                           │ │
│  │  RecommendService | UserProfileService | Ranking    │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ 内容服务     │  │ 用户服务     │  │ 行为服务     │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                  持久层 (Persistence)                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ MyBatis-Plus │  │ Redis       │  │ FileStorage │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                  数据层 (Data)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ MySQL       │  │ Redis       │  │ Local/OSS   │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 1.2 技术栈

| 层级 | 技术组件 | 版本 | 说明 |
|-----|---------|------|------|
| 核心框架 | Spring Boot | 3.5.10 | 应用框架 |
| Web框架 | Spring WebMVC | 3.5.10 | REST API |
| 持久层 | MyBatis-Plus | 3.5.5 | ORM框架 |
| 数据库 | MySQL | 8.4.0 | 主数据库 |
| 缓存 | Spring Data Redis | 3.5.10 | 分布式缓存 |
| JDK | OpenJDK | 21 | 运行环境（虚拟线程） |

### 1.3 应用模块划分

```
openrecommend
├── controller/         # 控制器层
├── service/          # 服务层
│   ├── recommend/    # 推荐服务
│   ├── content/      # 内容服务
│   ├── user/         # 用户服务
│   └── behavior/     # 行为服务
├── mapper/           # 数据访问层
├── entity/           # 实体类
├── dto/              # 数据传输对象
├── algorithm/        # 算法包
├── config/           # 配置类
├── enums/            # 枚举类
├── exception/        # 异常处理
├── utils/            # 工具类
└── constants/        # 常量定义
```

---

## 二、模块设计

### 2.1 表现层（Controller）

#### 2.1.1 推荐控制器

```java
@RestController
@RequestMapping("/api/recommend")
@Tag(name = "推荐服务", description = "内容推荐相关接口")
public class RecommendController {

    @Resource
    private RecommendService recommendService;

    /**
     * 获取个性化推荐
     */
    @PostMapping("/personal")
    @Operation(summary = "个性化推荐")
    public Result<RecommendResponse> getPersonalRecommend(
        @Valid @RequestBody RecommendRequest request
    ) {
        RecommendResponse response = recommendService.recommend(request);
        return Result.success(response);
    }

    /**
     * 获取热门内容
     */
    @GetMapping("/hot/{contentType}")
    @Operation(summary = "热门内容推荐")
    public Result<RecommendResponse> getHotContent(
        @PathVariable String contentType,
        @RequestParam(defaultValue = "20") Integer limit
    ) {
        RecommendResponse response = recommendService.recommendHot(contentType, limit);
        return Result.success(response);
    }

    /**
     * 获取相关推荐
     */
    @GetMapping("/related/{contentId}")
    @Operation(summary = "相关内容推荐")
    public Result<RecommendResponse> getRelatedRecommend(
        @PathVariable Long contentId,
        @RequestParam(defaultValue = "10") Integer limit
    ) {
        RecommendResponse response = recommendService.recommendRelated(contentId, limit);
        return Result.success(response);
    }
}
```

#### 2.1.2 内容控制器

```java
@RestController
@RequestMapping("/api/content")
@Tag(name = "内容管理", description = "内容管理相关接口")
public class ContentController {

    @Resource
    private ArticleService articleService;
    @Resource
    private ImageService imageService;
    @Resource
    private VideoService videoService;

    /**
     * 发布文章
     */
    @PostMapping("/article")
    @Operation(summary = "发布文章")
    public Result<Long> publishArticle(@Valid @RequestBody ArticlePublishRequest request) {
        Long articleId = articleService.publish(request);
        return Result.success(articleId);
    }

    /**
     * 获取文章详情
     */
    @GetMapping("/article/{id}")
    @Operation(summary = "获取文章详情")
    public Result<ArticleDetailResponse> getArticle(@PathVariable Long id) {
        ArticleDetailResponse response = articleService.getDetail(id);
        return Result.success(response);
    }

    /**
     * 上传图片
     */
    @PostMapping("/image")
    @Operation(summary = "上传图片")
    public Result<Long> uploadImage(@Valid @RequestBody ImageUploadRequest request) {
        Long imageId = imageService.upload(request);
        return Result.success(imageId);
    }

    /**
     * 上传视频
     */
    @PostMapping("/video")
    @Operation(summary = "上传视频")
    public Result<Long> uploadVideo(@Valid @RequestBody VideoUploadRequest request) {
        Long videoId = videoService.upload(request);
        return Result.success(videoId);
    }
}
```

### 2.2 业务层（Service）

#### 2.2.1 推荐服务接口

```java
public interface RecommendService {

    /**
     * 综合推荐
     */
    RecommendResponse recommend(RecommendRequest request);

    /**
     * 基于内容的推荐
     */
    RecommendResponse recommendByContent(Long userId, String contentType, int limit);

    /**
     * 协同过滤推荐
     */
    RecommendResponse recommendByCollaborativeFiltering(Long userId, String contentType, int limit);

    /**
     * 热门推荐
     */
    RecommendResponse recommendHot(String contentType, int limit);

    /**
     * 相关推荐
     */
    RecommendResponse recommendRelated(Long contentId, int limit);
}
```

#### 2.2.2 推荐服务实现

```java
@Service
public class RecommendServiceImpl implements RecommendService {

    @Resource
    private UserProfileService userProfileService;
    @Resource
    private FeatureService featureService;
    @Resource
    private RankingService rankingService;
    @Resource
    private CacheService cacheService;

    @Override
    public RecommendResponse recommend(RecommendRequest request) {
        Long userId = request.getUserId();
        String contentType = request.getContentType();
        int limit = request.getLimit();

        // 检查缓存
        String cacheKey = buildCacheKey(userId, contentType, "personal");
        RecommendResponse cached = cacheService.getRecommend(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 获取用户画像
        UserProfile profile = userProfileService.getById(userId);

        // 并行执行多种推荐策略
        CompletableFuture<List<RecommendItem>> contentFuture = CompletableFuture.supplyAsync(
            () -> recommendByContent(userId, contentType, limit * 2),
            virtualThreadExecutor
        );
        CompletableFuture<List<RecommendItem>> cfFuture = CompletableFuture.supplyAsync(
            () -> recommendByCollaborativeFiltering(userId, contentType, limit * 2),
            virtualThreadExecutor
        );
        CompletableFuture<List<RecommendItem>> hotFuture = CompletableFuture.supplyAsync(
            () -> recommendHot(contentType, limit / 2),
            virtualThreadExecutor
        );

        // 等待所有任务完成
        CompletableFuture.allOf(contentFuture, cfFuture, hotFuture).join();

        // 合并结果
        List<RecommendItem> candidates = new ArrayList<>();
        candidates.addAll(contentFuture.join());
        candidates.addAll(cfFuture.join());
        candidates.addAll(hotFuture.join());

        // 去重
        Map<Long, RecommendItem> uniqueMap = candidates.stream()
            .collect(Collectors.toMap(
                RecommendItem::getContentId,
                Function.identity(),
                (a, b) -> a.getScore() > b.getScore() ? a : b
            ));

        List<RecommendItem> uniqueCandidates = new ArrayList<>(uniqueMap.values());

        // 计算特征并排序
        List<RecommendItem> ranked = rankingService.rank(uniqueCandidates, profile, limit);

        // 多样性处理
        List<RecommendItem> diversified = applyDiversification(ranked);

        // 缓存结果
        RecommendResponse response = RecommendResponse.builder()
            .items(diversified)
            .build();
        cacheService.setRecommend(cacheKey, response, 30, TimeUnit.MINUTES);

        return response;
    }

    @Override
    public RecommendResponse recommendByContent(Long userId, String contentType, int limit) {
        UserProfile profile = userProfileService.getById(userId);
        List<Long> candidates = recallByTags(profile, limit);

        List<RecommendItem> items = featureService.calculateScore(candidates, profile);
        return RecommendResponse.builder().items(items).build();
    }

    @Override
    public RecommendResponse recommendByCollaborativeFiltering(Long userId, String contentType, int limit) {
        List<Long> candidates = recallByCollaborativeFiltering(userId, contentType, limit);
        List<RecommendItem> items = candidates.stream()
            .map(id -> RecommendItem.builder()
                .contentId(id)
                .score(calculateCFScore(userId, id))
                .build())
            .collect(Collectors.toList());
        return RecommendResponse.builder().items(items).build();
    }

    @Override
    public RecommendResponse recommendHot(String contentType, int limit) {
        List<Long> hotIds = cacheService.getHotContent(contentType, limit);
        List<RecommendItem> items = hotIds.stream()
            .map(id -> RecommendItem.builder()
                .contentId(id)
                .score(1.0)
                .build())
            .collect(Collectors.toList());
        return RecommendResponse.builder().items(items).build();
    }

    @Override
    public RecommendResponse recommendRelated(Long contentId, int limit) {
        List<Long> relatedIds = findSimilarContent(contentId, limit);
        List<RecommendItem> items = relatedIds.stream()
            .map(id -> RecommendItem.builder()
                .contentId(id)
                .score(calculateSimilarity(contentId, id))
                .build())
            .collect(Collectors.toList());
        return RecommendResponse.builder().items(items).build();
    }
}
```

#### 2.2.3 用户画像服务

```java
@Service
public class UserProfileServiceImpl implements UserProfileService {

    @Resource
    private UserProfileMapper userProfileMapper;
    @Resource
    private UserBehaviorMapper userBehaviorMapper;
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public UserProfile getById(Long userId) {
        // 先查缓存
        String cacheKey = "user_profile:" + userId;
        UserProfile cached = (UserProfile) redisTemplate.opsForValue().get(cacheKey);
        if (cached != null) {
            return cached;
        }

        // 查数据库
        UserProfile profile = userProfileMapper.selectByUserId(userId);
        if (profile == null) {
            // 创建默认画像
            profile = createDefaultProfile(userId);
            userProfileMapper.insert(profile);
        }

        // 缓存
        redisTemplate.opsForValue().set(cacheKey, profile, 1, TimeUnit.HOURS);

        return profile;
    }

    @Override
    public void updateAsync(Long userId) {
        CompletableFuture.runAsync(() -> {
            UserProfile profile = calculateProfile(userId);
            userProfileMapper.updateById(profile);

            // 清除缓存
            String cacheKey = "user_profile:" + userId;
            redisTemplate.delete(cacheKey);
        }, virtualThreadExecutor);
    }

    private UserProfile calculateProfile(Long userId) {
        // 获取用户近期行为
        List<UserBehavior> behaviors = userBehaviorMapper.selectRecentBehaviors(userId, 30);

        // 计算兴趣标签
        Map<String, Double> interestTags = calculateInterestTags(behaviors);

        // 计算内容偏好
        Map<String, Double> contentPreference = calculateContentPreference(behaviors);

        // 计算活跃时段
        List<Integer> activePeriods = calculateActivePeriods(behaviors);

        return UserProfile.builder()
            .userId(userId)
            .interestTags(interestTags)
            .contentPreference(contentPreference)
            .activePeriods(activePeriods)
            .build();
    }
}
```

#### 2.2.4 特征工程服务

```java
@Service
public class FeatureServiceImpl implements FeatureService {

    @Resource
    private ArticleMapper articleMapper;
    @Resource
    private ImageMapper imageMapper;
    @Resource
    private VideoMapper videoMapper;

    @Override
    public List<RecommendItem> calculateScore(List<Long> contentIds, UserProfile profile) {
        return contentIds.stream()
            .parallel()
            .map(contentId -> {
                ContentFeature feature = extractFeature(contentId);
                double score = calculateScore(feature, profile);
                return RecommendItem.builder()
                    .contentId(contentId)
                    .score(score)
                    .build();
            })
            .collect(Collectors.toList());
    }

    private ContentFeature extractFeature(Long contentId) {
        // 提取内容特征
        return ContentFeature.builder()
            .keywords(extractKeywords(contentId))
            .tags(extractTags(contentId))
            .build();
    }

    private double calculateScore(ContentFeature feature, UserProfile profile) {
        // 计算与用户画像的匹配度
        double tagScore = calculateTagMatch(feature, profile);
        double qualityScore = feature.getQualityScore();
        double freshnessScore = calculateFreshnessScore(feature.getPublishTime());

        return 0.5 * tagScore + 0.3 * qualityScore + 0.2 * freshnessScore;
    }
}
```

#### 2.2.5 排序服务

```java
@Service
public class RankingServiceImpl implements RankingService {

    @Override
    public List<RecommendItem> rank(List<RecommendItem> candidates, UserProfile profile, int limit) {
        // 计算综合得分
        candidates.forEach(item -> {
            double personalScore = item.getScore();
            double qualityScore = getQualityScore(item.getContentId());
            double popularityScore = getPopularityScore(item.getContentId());
            double freshnessScore = getFreshnessScore(item.getContentId());

            double finalScore = 0.4 * personalScore +
                              0.2 * qualityScore +
                              0.2 * popularityScore +
                              0.2 * freshnessScore;

            item.setScore(finalScore);
        });

        // 排序并返回topN
        return candidates.stream()
            .sorted(Comparator.comparing(RecommendItem::getScore).reversed())
            .limit(limit)
            .collect(Collectors.toList());
    }
}
```

### 2.3 持久层（Mapper）

```java
@Mapper
public interface ArticleMapper extends BaseMapper<Article> {

    /**
     * 根据标签查询文章
     */
    @Select("<script>" +
            "SELECT * FROM article " +
            "WHERE status = 1 " +
            "AND JSON_CONTAINS(tags, JSON_ARRAY(" +
            "<foreach collection='tags' item='tag' separator=','>'" +
            "'#{tag}'" +
            "</foreach>" +
            ")) " +
            "ORDER BY quality_score DESC " +
            "LIMIT #{limit}" +
            "</script>")
    List<Article> selectByTags(@Param("tags") Set<String> tags, @Param("limit") int limit);

    /**
     * 查询热门文章
     */
    @Select("SELECT * FROM article WHERE status = 1 " +
            "AND publish_time >= DATE_SUB(NOW(), INTERVAL #{days} DAY) " +
            "ORDER BY (view_count * 0.5 + like_count * 0.3 + comment_count * 0.2) DESC " +
            "LIMIT #{limit}")
    List<Article> selectHotArticles(@Param("days") int days, @Param("limit") int limit);

    /**
     * 查询未阅读的文章
     */
    @Select("<script>" +
            "SELECT * FROM article WHERE status = 1 " +
            "AND id NOT IN " +
            "<foreach collection='excludeIds' item='id' open='(' separator=',' close=')'>" +
            "#{id}" +
            "</foreach>" +
            "</script>")
    List<Article> selectNotInIds(@Param("excludeIds") List<Long> excludeIds);
}

@Mapper
public interface UserBehaviorMapper extends BaseMapper<UserBehavior> {

    /**
     * 查询用户近期行为
     */
    @Select("SELECT * FROM user_behavior " +
            "WHERE user_id = #{userId} " +
            "AND create_time >= DATE_SUB(NOW(), INTERVAL #{days} DAY) " +
            "ORDER BY create_time DESC")
    List<UserBehavior> selectRecentBehaviors(@Param("userId") Long userId,
                                             @Param("days") int days);

    /**
     * 查询用户历史内容ID
     */
    @Select("<script>" +
            "SELECT DISTINCT content_id FROM user_behavior " +
            "WHERE user_id = #{userId} " +
            "AND content_type = #{contentType} " +
            "</script>")
    List<Long> selectHistoryContentIds(@Param("userId") Long userId,
                                       @Param("contentType") String contentType);
}

@Mapper
public interface UserProfileMapper extends BaseMapper<UserProfile> {

    /**
     * 根据用户ID查询画像
     */
    @Select("SELECT * FROM user_profile WHERE user_id = #{userId}")
    UserProfile selectByUserId(@Param("userId") Long userId);
}
```

---

## 三、算法设计

### 3.1 基于内容的推荐算法

```java
public class ContentBasedRecommender {

    /**
     * TF-IDF关键词提取
     */
    public Map<String, Double> extractTfIdf(String text) {
        // 1. 分词
        List<String> words = segment(text);

        // 2. 计算词频(TF)
        Map<String, Integer> tf = calculateTermFrequency(words);

        // 3. 计算逆文档频率(IDF)
        Map<String, Double> idf = calculateInverseDocumentFrequency(words);

        // 4. 计算TF-IDF
        Map<String, Double> tfidf = new HashMap<>();
        tf.forEach((word, freq) -> {
            tfidf.put(word, freq * idf.get(word));
        });

        // 5. 返回top K关键词
        return tfidf.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(20)
            .collect(Collectors.toMap(
                Map.Entry::getKey,
                Map.Entry::getValue
            ));
    }

    /**
     * 余弦相似度计算
     */
    public double cosineSimilarity(Map<String, Double> vector1,
                                   Map<String, Double> vector2) {
        // 计算点积
        double dotProduct = 0;
        for (String key : vector1.keySet()) {
            if (vector2.containsKey(key)) {
                dotProduct += vector1.get(key) * vector2.get(key);
            }
        }

        // 计算向量模
        double norm1 = Math.sqrt(vector1.values().stream()
            .mapToDouble(v -> v * v).sum());
        double norm2 = Math.sqrt(vector2.values().stream()
            .mapToDouble(v -> v * v).sum());

        return dotProduct / (norm1 * norm2);
    }
}
```

### 3.2 协同过滤算法

```java
public class CollaborativeFiltering {

    /**
     * 计算用户相似度（余弦相似度）
     */
    public double calculateUserSimilarity(Long user1, Long user2) {
        // 获取两个用户的行为向量
        Map<Long, Double> vector1 = getUserBehaviorVector(user1);
        Map<Long, Double> vector2 = getUserBehaviorVector(user2);

        // 计算余弦相似度
        return cosineSimilarity(vector1, vector2);
    }

    /**
     * 计算物品相似度
     */
    public double calculateItemSimilarity(Long item1, Long item2) {
        // 获取对两个物品产生行为的用户集合
        Set<Long> users1 = getUsersByItem(item1);
        Set<Long> users2 = getUsersByItem(item2);

        // 计算交集
        Set<Long> intersection = new HashSet<>(users1);
        intersection.retainAll(users2);

        // 改进的相似度公式
        int union = users1.size() + users2.size() - intersection.size();
        return (double) intersection.size() / Math.sqrt(users1.size() * users2.size());
    }

    /**
     * 基于用户的协同过滤
     */
    public List<Long> recommendByUserCF(Long userId, int k, int n) {
        // 1. 找到K个最相似的用户
        List<Long> similarUsers = findKNearestUsers(userId, k);

        // 2. 统计这些用户喜欢但目标用户未互动的内容
        Map<Long, Double> candidateScores = new HashMap<>();
        for (Long similarUser : similarUsers) {
            List<Long> likedItems = getLikedItems(similarUser);
            for (Long item : likedItems) {
                if (!hasInteracted(userId, item)) {
                    double similarity = calculateUserSimilarity(userId, similarUser);
                    candidateScores.merge(item, similarity, Double::sum);
                }
            }
        }

        // 3. 返回Top N
        return candidateScores.entrySet().stream()
            .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
            .limit(n)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }
}
```

### 3.3 混合推荐算法

```java
public class HybridRecommender {

    /**
     * 加权融合
     */
    public double weightedFusion(double contentScore, double cfScore,
                                  double popularityScore,
                                  Map<String, Double> weights) {
        return weights.get("content") * contentScore +
               weights.get("cf") * cfScore +
               weights.get("popularity") * popularityScore;
    }

    /**
     * 动态权重计算
     */
    public Map<String, Double> calculateDynamicWeights(UserProfile profile) {
        int behaviorCount = profile.getTotalViewCount();

        Map<String, Double> weights = new HashMap<>();

        if (behaviorCount < 10) {
            // 新用户：偏向内容推荐和热门推荐
            weights.put("content", 0.7);
            weights.put("cf", 0.1);
            weights.put("popularity", 0.2);
        } else if (behaviorCount < 100) {
            // 中等活跃用户：平衡
            weights.put("content", 0.4);
            weights.put("cf", 0.4);
            weights.put("popularity", 0.2);
        } else {
            // 高活跃用户：偏向协同过滤
            weights.put("content", 0.3);
            weights.put("cf", 0.6);
            weights.put("popularity", 0.1);
        }

        return weights;
    }
}
```

---

## 四、接口设计

### 4.1 统一响应格式

```java
@Data
@Builder
public class Result<T> {
    private Integer code;
    private String message;
    private T data;
    private Long timestamp;

    public static <T> Result<T> success(T data) {
        return Result.<T>builder()
            .code(200)
            .message("success")
            .data(data)
            .timestamp(System.currentTimeMillis())
            .build();
    }

    public static <T> Result<T> error(Integer code, String message) {
        return Result.<T>builder()
            .code(code)
            .message(message)
            .timestamp(System.currentTimeMillis())
            .build();
    }
}
```

### 4.2 推荐接口

#### 4.2.1 个性化推荐

```java
@Data
public class RecommendRequest {
    @NotNull(message = "用户ID不能为空")
    private Long userId;

    @NotBlank(message = "内容类型不能为空")
    private String contentType; // article/image/video/all

    @Min(value = 10, message = "推荐数量最小为10")
    @Max(value = 50, message = "推荐数量最大为50")
    private Integer limit = 20;

    private String device; // mobile/pc/tablet
}

@Data
@Builder
public class RecommendResponse {
    private List<RecommendItem> items;
    private Long timestamp;
}

@Data
@Builder
public class RecommendItem {
    private Long contentId;
    private String contentType;
    private Double score;
    private String reason; // 推荐理由
}
```

#### 4.2.2 内容详情接口

```java
@Data
@Builder
public class ArticleDetailResponse {
    private Long id;
    private String title;
    private String summary;
    private String coverImage;
    private List<String> tags;
    private String authorName;
    private Integer viewCount;
    private Integer likeCount;
    private LocalDateTime publishTime;
}
```

---

## 五、配置设计

### 5.1 应用配置

```yaml
# application.yml
server:
  port: 8080
  servlet:
    context-path: /

spring:
  application:
    name: openrecommend

  datasource:
    url: jdbc:mysql://localhost:3306/openrecommend?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
    username: root
    password: root123456
    driver-class-name: com.mysql.cj.jdbc.Driver

  data:
    redis:
      host: localhost
      port: 6379
      database: 0
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: true
  global-config:
    db-config:
      logic-delete-field: isDeleted
      logic-delete-value: 1
      logic-not-delete-value: 0

# 推荐配置
recommend:
  recall:
    content-count: 200
    cf-count: 200
    hot-count: 100
  ranking:
    candidate-size: 1000
    result-size: 20
  cache:
    user-profile-ttl: 3600
    recommend-result-ttl: 1800
    hot-content-ttl: 3600

# 日志配置
logging:
  level:
    root: INFO
    com.qoobot.openrecommend: DEBUG
  file:
    name: logs/openrecommend.log
```

### 5.2 MyBatis-Plus配置

```java
@Configuration
@MapperScan("com.qoobot.openrecommend.mapper")
public class MyBatisPlusConfig {

    /**
     * 分页插件
     */
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor() {
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();

        // 分页插件
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL));

        // 乐观锁插件
        interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor());

        return interceptor;
    }

    /**
     * 自动填充
     */
    @Bean
    public MetaObjectHandler metaObjectHandler() {
        return new MetaObjectHandler() {
            @Override
            public void insertFill(MetaObject metaObject) {
                this.strictInsertFill(metaObject, "createTime", LocalDateTime.class, LocalDateTime.now());
                this.strictInsertFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
            }

            @Override
            public void updateFill(MetaObject metaObject) {
                this.strictUpdateFill(metaObject, "updateTime", LocalDateTime.class, LocalDateTime.now());
            }
        };
    }
}
```

### 5.3 Redis配置

```java
@Configuration
public class RedisConfig {

    @Bean
    public RedisTemplate<String, Object> redisTemplate(RedisConnectionFactory factory) {
        RedisTemplate<String, Object> template = new RedisTemplate<>();
        template.setConnectionFactory(factory);

        // Key序列化
        StringRedisSerializer keySerializer = new StringRedisSerializer();
        template.setKeySerializer(keySerializer);
        template.setHashKeySerializer(keySerializer);

        // Value序列化
        GenericJackson2JsonRedisSerializer valueSerializer =
            new GenericJackson2JsonRedisSerializer();
        template.setValueSerializer(valueSerializer);
        template.setHashValueSerializer(valueSerializer);

        template.afterPropertiesSet();
        return template;
    }

    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

### 5.4 线程池配置（虚拟线程）

```java
@Configuration
public class ThreadPoolConfig {

    @Bean("virtualThreadExecutor")
    public ExecutorService virtualThreadExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }

    @Bean("taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}
```

---

## 六、异常处理

### 6.1 统一异常处理

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    /**
     * 业务异常
     */
    @ExceptionHandler(BusinessException.class)
    public Result<?> handleBusinessException(BusinessException e) {
        log.error("业务异常: {}", e.getMessage());
        return Result.error(e.getCode(), e.getMessage());
    }

    /**
     * 参数校验异常
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    public Result<?> handleValidationException(MethodArgumentNotValidException e) {
        String message = e.getBindingResult().getFieldErrors().stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.joining(", "));
        return Result.error(400, message);
    }

    /**
     * 系统异常
     */
    @ExceptionHandler(Exception.class)
    public Result<?> handleException(Exception e) {
        log.error("系统异常", e);
        return Result.error(500, "系统异常，请稍后重试");
    }
}
```

### 6.2 业务异常定义

```java
@Data
public class BusinessException extends RuntimeException {
    private Integer code;

    public BusinessException(String message) {
        super(message);
        this.code = 500;
    }

    public BusinessException(Integer code, String message) {
        super(message);
        this.code = code;
    }
}
```

---

## 七、监控与日志

### 7.1 Actuator监控

```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      probes:
        enabled: true
  metrics:
    export:
      prometheus:
        enabled: true
```

### 7.2 日志配置

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/openrecommend.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/openrecommend.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

---

## 八、附录

### 8.1 应用启动类

```java
@SpringBootApplication
@EnableAsync
@EnableCaching
public class OpenRecommendApplication {
    public static void main(String[] args) {
        SpringApplication.run(OpenRecommendApplication.class, args);
    }
}
```

### 8.2 核心常量定义

```java
public class RecommendConstants {

    // 推荐类型
    public static final String RECOMMEND_TYPE_PERSONAL = "personal";
    public static final String RECOMMEND_TYPE_HOT = "hot";
    public static final String RECOMMEND_TYPE_RELATED = "related";

    // 内容类型
    public static final String CONTENT_TYPE_ARTICLE = "article";
    public static final String CONTENT_TYPE_IMAGE = "image";
    public static final String CONTENT_TYPE_VIDEO = "video";
    public static final String CONTENT_TYPE_ALL = "all";

    // 权重配置
    public static final double WEIGHT_CONTENT_NEW_USER = 0.7;
    public static final double WEIGHT_CF_NEW_USER = 0.1;
    public static final double WEIGHT_POPULARITY = 0.2;

    public static final double WEIGHT_CONTENT_OLD_USER = 0.3;
    public static final double WEIGHT_CF_OLD_USER = 0.6;
}
```
