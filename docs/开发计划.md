# 多内容类型智能推荐系统开发计划

## 项目概述

**项目名称**: OpenRecommend - 多内容类型智能推荐系统
**版本**: 1.0.0
**架构模式**: 单体应用
**开发周期**: 10周（约2.5个月）
**目标**: 构建一个功能完善、简洁高效的单体服务，支持文章、图片和视频的个性化推荐

---

## 一、系统架构设计

### 1.1 整体架构

```
┌─────────────────────────────────────────────────────────────┐
│                      表现层 (Presentation)                     │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐      │
│  │ REST API     │  │ 管理后台API   │  │ 对外推荐API   │      │
│  └──────────────┘  └──────────────┘  └──────────────┘      │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────────┐
│                   业务层 (Business Layer)                    │
│  ┌────────────────────────────────────────────────────┐   │
│  │            推荐引擎核心模块                          │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐       │   │
│  │  │内容推荐器 │  │用户画像   │  │特征工程   │       │   │
│  │  └──────────┘  └──────────┘  └──────────┘       │   │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐       │   │
│  │  │相似度计算 │  │排序模块   │  │多样性处理 │       │   │
│  │  └──────────┘  └──────────┘  └──────────┘       │   │
│  └────────────────────────────────────────────────────┘   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │ 内容管理服务 │  │ 用户行为服务 │  │ 数据分析服务 │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────────┐
│                   持久层 (Persistence Layer)                   │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ MyBatis-Plus │  │ Redis缓存    │  │ 数据访问对象 │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└────────────────────┬────────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────────┐
│                   数据层 (Data Layer)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐        │
│  │ MySQL 8.0+  │  │ Redis 7.x   │  │ 文件存储     │        │
│  │ (主数据库)   │  │ (缓存/队列) │  │ (OSS/本地)  │        │
│  └─────────────┘  └─────────────┘  └─────────────┘        │
└─────────────────────────────────────────────────────────────┘
```

### 1.2 技术栈

| 层级 | 技术组件 | 版本 | 用途说明 |
|-----|---------|------|---------|
| 核心框架 | Spring Boot | 3.5.10 | 应用框架，提供自动配置、依赖注入等 |
| Web框架 | Spring WebMVC | 3.5.10 | RESTful API开发 |
| 持久层 | MyBatis-Plus | 3.5.5 | ORM框架，简化数据库操作 |
| 数据库 | MySQL | 8.4.0 | 主数据库，存储业务数据 |
| 连接池 | HikariCP | 6.3.3 | 数据库连接池（Spring Boot默认） |
| 缓存 | Spring Data Redis | 3.5.10 | 分布式缓存，提升查询性能 |
| 数据校验 | Hibernate Validator | 8.0.3 | 请求参数校验 |
| JSON处理 | Jackson | 2.16.0 | JSON序列化/反序列化 |
| 工具库 | Hutool | 5.8.23 | 常用工具类集合 |
| Lombok | Lombok | 1.18.42 | 简化Java代码 |
| JDK | OpenJDK | 21 | 运行环境，利用虚拟线程特性 |

### 1.3 包结构设计

```
com.qoobot.openrecommend
├── OpenRecommendApplication.java          # 启动类
├── config                                 # 配置类
│   ├── MyBatisPlusConfig.java            # MyBatis-Plus配置
│   ├── RedisConfig.java                  # Redis配置
│   ├── WebMvcConfig.java                 # Web MVC配置
│   └── ThreadPoolConfig.java             # 线程池配置（虚拟线程）
├── controller                             # 控制器层
│   ├── RecommendController.java          # 推荐API
│   ├── ContentController.java            # 内容管理API
│   ├── UserController.java               # 用户API
│   └── AdminController.java              # 管理后台API
├── service                                # 服务层
│   ├── recommend                         # 推荐服务
│   │   ├── RecommendService.java         # 推荐服务接口
│   │   ├── impl
│   │   │   ├── ArticleRecommender.java   # 文章推荐器
│   │   │   ├── ImageRecommender.java     # 图片推荐器
│   │   │   ├── VideoRecommender.java     # 视频推荐器
│   │   │   └── MixedRecommender.java     # 混合推荐器
│   │   ├── UserProfileService.java      # 用户画像服务
│   │   ├── FeatureService.java           # 特征工程服务
│   │   ├── SimilarityService.java        # 相似度计算服务
│   │   └── RankingService.java           # 排序服务
│   ├── content                           # 内容服务
│   │   ├── ArticleService.java           # 文章服务
│   │   ├── ImageService.java             # 图片服务
│   │   └── VideoService.java             # 视频服务
│   ├── behavior                          # 行为服务
│   │   ├── UserBehaviorService.java      # 用户行为服务
│   │   └── StatisticsService.java        # 统计服务
│   └── common                            # 公共服务
│       ├── CacheService.java             # 缓存服务
│       └── SearchService.java            # 搜索服务
├── mapper                                 # 数据访问层（MyBatis-Plus）
│   ├── ArticleMapper.java
│   ├── ImageMapper.java
│   ├── VideoMapper.java
│   ├── UserMapper.java
│   ├── UserBehaviorMapper.java
│   └── UserProfileMapper.java
├── entity                                 # 实体类
│   ├── Article.java
│   ├── Image.java
│   ├── Video.java
│   ├── User.java
│   ├── UserBehavior.java
│   ├── UserProfile.java
│   └── BaseDO.java                       # 基础实体
├── dto                                    # 数据传输对象
│   ├── request                           # 请求DTO
│   │   ├── RecommendRequest.java
│   │   ├── ContentQueryRequest.java
│   │   └── UserActionRequest.java
│   └── response                          # 响应DTO
│       ├── RecommendResponse.java
│       ├── ContentDetailResponse.java
│       └── Result.java                   # 统一响应结果
├── algorithm                              # 算法包
│   ├── contentbased                      # 基于内容的推荐算法
│   │   ├── ContentBasedRecommender.java
│   │   ├── TfIdfCalculator.java
│   │   └── SimilarityCalculator.java
│   ├── collaborative                     # 协同过滤算法
│   │   ├── CollaborativeFiltering.java
│   │   ├── UserBasedCF.java
│   │   └── ItemBasedCF.java
│   ├── hybrid                            # 混合推荐算法
│   │   └── HybridRecommender.java
│   └── utils                             # 算法工具类
│       ├── VectorUtil.java
│       └── StatisticsUtil.java
├── enums                                  # 枚举类
│   ├── ContentTypeEnum.java
│   ├── BehaviorTypeEnum.java
│   ├── RecommendTypeEnum.java
│   └── StatusEnum.java
├── exception                              # 异常处理
│   ├── BusinessException.java
│   └── GlobalExceptionHandler.java
├── utils                                  # 工具类
│   ├── JsonUtil.java
│   ├── DateUtil.java
│   └── StringUtil.java
└── constants                              # 常量定义
    ├── CacheConstants.java
    ├── RecommendConstants.java
    └── SystemConstants.java
```

### 1.4 技术组件协同工作流程

```
1. 请求处理流程：
   用户请求 → Controller接收 → 参数校验 → Service业务处理
            ↓
   Mapper数据访问 → MySQL查询 → 返回数据 → Service处理
            ↓
   Algorithm算法计算 → Redis缓存 → Controller组装响应

2. 推荐处理流程：
   RecommendController → RecommendService → UserProfileService
                          ↓
                   获取用户画像
                          ↓
                 ┌────────┴────────┐
                 ↓                 ↓
          ContentRecommender  SimilarityService
                 ↓                 ↓
          FeatureService      相似度计算
                 ↓                 ↓
          RankingService ←──────┘
                 ↓
          多样性处理
                 ↓
          CacheService缓存
                 ↓
          返回推荐结果

3. 数据写入流程：
   用户行为 → UserBehaviorService → UserBehaviorMapper
            ↓
     MySQL写入
            ↓
     异步更新用户画像 → UserProfileService → UserProfileMapper
            ↓
     清除相关Redis缓存
```

---

## 二、推荐算法实现方案

### 2.1 推荐算法架构

```
┌─────────────────────────────────────────────────────────┐
│                  推荐引擎核心架构                         │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │ 基于内容推荐 │  │ 协同过滤推荐 │  │ 混合推荐策略 │     │
│  │ (Content-   │  │ (CF)        │  │ (Hybrid)    │     │
│  │  Based)     │  │             │  │             │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │ 热门推荐     │  │ 新品推荐     │  │ 个性化推荐   │     │
│  │ (Popular)   │  │ (Latest)    │  │ (Personal)  │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
├─────────────────────────────────────────────────────────┤
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐     │
│  │ 候选集召回   │  │ 特征计算     │  │ 排序打分     │     │
│  └─────────────┘  └─────────────┘  └─────────────┘     │
└─────────────────────────────────────────────────────────┘
```

### 2.2 核心算法详解

#### 2.2.1 基于内容的推荐算法

**适用场景**: 冷启动、新用户、新内容

**文章推荐 - TF-IDF + 余弦相似度**:

```java
// 算法流程
1. 提取文章关键词（使用分词 + TF-IDF）
2. 构建文章-关键词矩阵
3. 计算用户偏好向量（基于用户浏览、点赞、收藏的文章）
4. 计算文章与用户偏好的余弦相似度
5. 按相似度排序推荐

// 相似度计算公式
similarity = cos(θ) = (A·B) / (||A|| × ||B||)
其中 A 为用户偏好向量，B 为文章特征向量
```

**图片推荐 - 视觉特征相似度**:

```java
// 算法流程
1. 提取图片视觉特征：
   - 颜色直方图 (HSV色彩空间)
   - 纹理特征 (LBP/灰度共生矩阵)
   - 形状特征 (轮廓描述子)
2. 计算用户偏好的视觉特征向量
3. 计算欧氏距离或余弦相似度
4. 推荐相似度高的图片

// 简化实现（不依赖深度学习）
- 使用ImageIO读取图片
- 计算颜色分布直方图
- 比较直方图相似度
```

**视频推荐 - 多特征融合**:

```java
// 算法流程
1. 提取关键帧（采样5-10帧）
2. 提取标题、描述文本特征
3. 计算视频时长、清晰度等元数据特征
4. 融合文本特征 + 视觉特征 + 元数据特征
5. 计算综合相似度

// 特征权重配置
- 文本特征：50%
- 视觉特征：30%
- 元数据特征：20%
```

#### 2.2.2 协同过滤推荐算法

**基于用户的协同过滤 (User-based CF)**:

```java
// 算法流程
1. 收集用户-物品评分矩阵（隐式评分：浏览、点赞、收藏）
2. 计算用户之间的相似度（皮尔逊相关系数 / 余弦相似度）
3. 找到目标用户的K个最近邻
4. 推荐相似用户喜欢但目标用户未互动的内容

// 用户相似度计算
sim(u,v) = Σ(item_i)(r_ui - r_u_avg)(r_vi - r_v_avg) / 
           sqrt(Σ(r_ui - r_u_avg)²) * sqrt(Σ(r_vi - r_v_avg)²)
```

**基于物品的协同过滤 (Item-based CF)**:

```java
// 算法流程
1. 构建物品-用户矩阵
2. 计算物品之间的相似度
3. 基于用户历史行为，找到相似物品
4. 推荐与已浏览物品相似的内容

// 物品相似度计算（改进版）
sim(i,j) = |U_i ∩ U_j| / (|U_i|^(0.5) × |U_j|^(0.5))
其中 U_i 为对物品i产生行为的用户集合
```

#### 2.2.3 混合推荐算法

```java
// 加权融合策略
final_score = α × content_score + β × cf_score + γ × popularity_score

// 参数配置
- 新用户：α=0.7, β=0.1, γ=0.2 (偏向内容推荐)
- 老用户：α=0.3, β=0.6, γ=0.1 (偏向协同过滤)
- 热门时段：α=0.2, β=0.3, γ=0.5 (偏向热门内容)

// 分层策略
第一层：基于内容召回（召回1000条）
第二层：协同过滤重排（保留200条）
第三层：多样性处理（输出20-50条）
```

### 2.3 推荐流程

```
┌─────────────────────────────────────────────────────────┐
│                    推荐请求处理流程                        │
├─────────────────────────────────────────────────────────┤
│                                                         │
│  Step 1: 接收请求                                        │
│    ↓ 推荐类型、用户ID、内容类型、数量等参数               │
│                                                         │
│  Step 2: 获取用户画像                                   │
│    ↓ 从Redis缓存读取，未命中则查询MySQL                   │
│    ↓ 包含：兴趣标签、历史行为、偏好内容类型等              │
│                                                         │
│  Step 3: 候选集召回 (Recall)                             │
│    ↓ 并行执行多种召回策略                                │
│    ├─ 基于内容召回：标签匹配、关键词相似                  │
│    ├─ 协同过滤召回：相似用户/物品                         │
│    ├─ 热门召回：近期高热度内容                           │
│    └─ 新品召回：最近发布的高质量内容                      │
│    ↓ 合并去重，得到候选集（如1000条）                     │
│                                                         │
│  Step 4: 特征提取与计算 (Feature Extraction)             │
│    ↓ 对每条候选内容计算特征向量                           │
│    ├─ 文章：文本特征、主题特征                           │
│    ├─ 图片：视觉特征、元数据特征                          │
│    └─ 视频：多模态特征融合                               │
│                                                         │
│  Step 5: 排序打分 (Ranking)                             │
│    ↓ 应用排序模型计算得分                                │
│    ├─ 个性化得分：与用户画像匹配度                       │
│    ├─ 内容质量得分：内容完整性、原创度                   │
│    ├─ 热度得分：浏览量、互动率                           │
│    └─ 新鲜度得分：发布时间衰减                           │
│    ↓ 按综合得分排序，取前N条（如200条）                  │
│                                                         │
│  Step 6: 多样性处理 (Diversification)                    │
│    ↓ 确保推荐结果的多样性                                │
│    ├─ 分类多样性：控制不同分类的占比                      │
│    ├─ 时间多样性：混合不同时间段内容                      │
│    └─ 来源多样性：避免单一来源                           │
│                                                         │
│  Step 7: 结果缓存 (Caching)                             │
│    ↓ 将推荐结果存入Redis                                 │
│    ↓ 缓存有效期：10-30分钟                               │
│                                                         │
│  Step 8: 返回响应                                        │
│    ↓ 组装推荐结果，返回给客户端                          │
│                                                         │
└─────────────────────────────────────────────────────────┘
```

---

## 三、各内容类型推荐逻辑

### 3.1 文章推荐逻辑

#### 3.1.1 数据特征

**文本特征**:
- 标题关键词（分词后权重更高）
- 正文关键词（TF-IDF提取）
- 摘要文本
- 分类标签
- 用户标签

**元数据特征**:
- 字数统计
- 阅读时长
- 发布时间
- 作者信息
- 原创度标记

**互动特征**:
- 浏览量
- 点赞数
- 评论数
- 收藏数
- 分享数
- 完读率

#### 3.1.2 推荐策略

**策略1: 基于兴趣标签推荐**
```java
// 伪代码
List<Article> recommendByTags(Long userId, int limit) {
    // 1. 获取用户兴趣标签及权重
    Map<String, Double> userTags = getUserInterestTags(userId);

    // 2. 查询匹配标签的文章
    List<Article> candidates = articleMapper.selectByTags(userTags.keySet());

    // 3. 计算文章得分
    for (Article article : candidates) {
        double score = calculateScore(article, userTags);
        article.setScore(score);
    }

    // 4. 排序返回
    return candidates.stream()
        .sorted(Comparator.comparing(Article::getScore).reversed())
        .limit(limit)
        .collect(Collectors.toList());
}

// 得分计算
double calculateScore(Article article, Map<String, Double> userTags) {
    double tagScore = 0;
    for (String tag : article.getTags()) {
        if (userTags.containsKey(tag)) {
            tagScore += userTags.get(tag);
        }
    }

    // 归一化处理
    tagScore = tagScore / article.getTags().size();

    // 综合得分
    double qualityScore = article.getQualityScore();
    double popularityScore = Math.log(article.getViewCount() + 1) / 10;

    return 0.6 * tagScore + 0.2 * qualityScore + 0.2 * popularityScore;
}
```

**策略2: 基于相似文章推荐**
```java
// 相似文章推荐（基于已阅读文章）
List<Article> recommendSimilar(Long userId, int limit) {
    // 1. 获取用户最近阅读的10篇文章
    List<Article> historyArticles = getUserRecentReadArticles(userId, 10);

    // 2. 提取这些文章的向量
    List<Map<String, Double>> historyVectors = historyArticles.stream()
        .map(this::extractVector)
        .collect(Collectors.toList());

    // 3. 计算用户偏好向量（平均）
    Map<String, Double> userVector = averageVectors(historyVectors);

    // 4. 查询未阅读的文章
    List<Long> readArticleIds = historyArticles.stream()
        .map(Article::getId)
        .collect(Collectors.toList());
    List<Article> candidates = articleMapper.selectNotInIds(readArticleIds);

    // 5. 计算相似度并排序
    for (Article article : candidates) {
        Map<String, Double> articleVector = extractVector(article);
        double similarity = cosineSimilarity(userVector, articleVector);
        article.setSimilarity(similarity);
    }

    return candidates.stream()
        .sorted(Comparator.comparing(Article::getSimilarity).reversed())
        .limit(limit)
        .collect(Collectors.toList());
}
```

#### 3.1.3 实现要点

- 使用IK分词器进行中文分词
- TF-IDF关键词提取（保留前20个关键词）
- Redis缓存文章特征向量
- 定期（每日）更新文章质量分

### 3.2 图片推荐逻辑

#### 3.2.1 数据特征

**视觉特征**:
- 颜色分布：HSV色彩空间直方图
- 纹理特征：LBP（局部二值模式）
- 尺寸信息：宽度、高度、宽高比

**文本特征**:
- 标题
- 描述文本
- 分类标签
- 关键词

**互动特征**:
- 浏览量
- 点赞数
- 收藏数
- 下载次数

#### 3.2.2 推荐策略

**策略1: 基于视觉相似度推荐**
```java
// 视觉相似度计算（简化版）
List<Image> recommendByVisualSimilarity(Long userId, int limit) {
    // 1. 获取用户喜欢的图片视觉特征
    List<Map<String, Double>> likedImageFeatures = getUserLikedImageFeatures(userId);

    // 2. 计算用户偏好的平均视觉特征
    Map<String, Double> userVisualPreference = averageVisualFeatures(likedImageFeatures);

    // 3. 查询候选图片
    List<Image> candidates = imageMapper.selectAll();

    // 4. 计算视觉相似度
    for (Image image : candidates) {
        Map<String, Double> imageFeature = extractVisualFeature(image);
        double similarity = calculateVisualSimilarity(userVisualPreference, imageFeature);
        image.setVisualSimilarity(similarity);
    }

    // 5. 排序返回
    return candidates.stream()
        .sorted(Comparator.comparing(Image::getVisualSimilarity).reversed())
        .limit(limit)
        .collect(Collectors.toList());
}

// 颜色相似度计算（简化版 - HSV直方图）
double calculateColorSimilarity(Map<String, Double> hist1, Map<String, Double> hist2) {
    double sum = 0;
    for (String key : hist1.keySet()) {
        double v1 = hist1.get(key);
        double v2 = hist2.getOrDefault(key, 0.0);
        sum += Math.abs(v1 - v2);
    }
    return 1 - (sum / hist1.size()); // 越小越相似，转为越大越相似
}
```

**策略2: 基于风格/主题推荐**
```java
// 基于标签和描述的推荐
List<Image> recommendByTheme(Long userId, int limit) {
    // 1. 获取用户图片浏览历史，提取偏好主题
    List<Image> history = getUserImageHistory(userId);
    Map<String, Integer> themePreference = extractThemePreference(history);

    // 2. 查询匹配主题的图片
    List<Image> candidates = imageMapper.selectByThemes(themePreference.keySet());

    // 3. 计算主题匹配度
    for (Image image : candidates) {
        double themeScore = calculateThemeScore(image, themePreference);
        image.setThemeScore(themeScore);
    }

    // 4. 综合评分
    for (Image image : candidates) {
        double visualScore = calculateVisualScore(image);
        double popularityScore = calculatePopularityScore(image);
        double finalScore = 0.5 * image.getThemeScore() +
                           0.3 * visualScore +
                           0.2 * popularityScore;
        image.setFinalScore(finalScore);
    }

    return candidates.stream()
        .sorted(Comparator.comparing(Image::getFinalScore).reversed())
        .limit(limit)
        .collect(Collectors.toList());
}
```

#### 3.2.3 实现要点

- 图片元数据在上传时提取（使用ImageIO）
- 颜色直方图：HSV空间量化为64维
- 定期（每日）更新图片热度分
- 使用CDN加速图片访问

### 3.3 视频推荐逻辑

#### 3.3.1 数据特征

**多模态特征**:
- 文本特征：标题、描述、标签
- 视觉特征：关键帧特征（采样）
- 音频特征：音频类型、时长（简化版）
- 元数据特征：时长、清晰度、分类

**互动特征**:
- 播放量
- 点赞数
- 评论数
- 收藏数
- 分享数
- 完播率

#### 3.3.2 推荐策略

**策略1: 多特征融合推荐**
```java
// 多特征融合推荐
List<Video> recommendByMultiFeature(Long userId, int limit) {
    // 1. 获取用户画像
    UserProfile profile = userProfileService.getById(userId);

    // 2. 召回候选视频
    List<Video> candidates = videoMapper.selectCandidates(profile);

    // 3. 计算各项得分
    for (Video video : candidates) {
        // 文本相似度得分
        double textScore = calculateTextSimilarity(video, profile);

        // 视觉相似度得分（基于封面图）
        double visualScore = calculateVisualSimilarity(video.getCover(), profile);

        // 元数据匹配得分
        double metaScore = calculateMetadataMatch(video, profile);

        // 热度得分
        double popularityScore = Math.log(video.getViewCount() + 1) / 10;

        // 新鲜度得分（时间衰减）
        double freshnessScore = calculateFreshnessScore(video.getPublishTime());

        // 综合得分
        double finalScore = 0.35 * textScore +
                           0.25 * visualScore +
                           0.15 * metaScore +
                           0.15 * popularityScore +
                           0.10 * freshnessScore;

        video.setFinalScore(finalScore);
    }

    // 4. 排序并应用多样性
    List<Video> ranked = candidates.stream()
        .sorted(Comparator.comparing(Video::getFinalScore).reversed())
        .collect(Collectors.toList());

    return applyDiversification(ranked, limit);
}
```

**策略2: 基于观看序列推荐**
```java
// 基于用户观看序列的推荐（简化版Item-based CF）
List<Video> recommendBySequence(Long userId, int limit) {
    // 1. 获取用户最近观看的10个视频
    List<Video> recentWatched = videoMapper.selectRecentWatched(userId, 10);

    // 2. 找出与这些视频相似的视频
    List<Video> similarVideos = new ArrayList<>();
    for (Video watched : recentWatched) {
        // 查找相似视频（基于标签、分类、内容）
        List<Video> similar = findSimilarVideos(watched, 5);
        similarVideos.addAll(similar);
    }

    // 3. 去重并计算相似度总和
    Map<Long, Double> videoScores = new HashMap<>();
    for (Video video : similarVideos) {
        if (!isWatched(userId, video.getId())) {
            videoScores.merge(video.getId(), video.getSimilarity(), Double::sum);
        }
    }

    // 4. 按得分排序
    List<Long> sortedIds = videoScores.entrySet().stream()
        .sorted(Map.Entry.<Long, Double>comparingByValue().reversed())
        .map(Map.Entry::getKey)
        .collect(Collectors.toList());

    // 5. 返回推荐结果
    return videoMapper.selectByIds(sortedIds).stream()
        .limit(limit)
        .collect(Collectors.toList());
}
```

#### 3.3.3 实现要点

- 视频封面图提取视觉特征
- 标题和描述文本进行关键词提取
- 考虑视频时长匹配用户偏好
- 考虑视频清晰度偏好
- 热门视频适当加权

### 3.4 跨内容类型推荐

```java
// 混合内容类型推荐
RecommendResult recommendMixed(Long userId, int totalLimit) {
    UserProfile profile = userProfileService.getById(userId);

    // 根据用户偏好分配各类型推荐数量
    Map<ContentType, Integer> allocation = calculateAllocation(profile, totalLimit);

    // 并行获取各类型推荐
    List<RecommendItem> articles = recommendArticles(userId, allocation.get(ContentType.ARTICLE));
    List<RecommendItem> images = recommendImages(userId, allocation.get(ContentType.IMAGE));
    List<RecommendItem> videos = recommendVideos(userId, allocation.get(ContentType.VIDEO));

    // 合并并排序
    List<RecommendItem> result = new ArrayList<>();
    result.addAll(articles);
    result.addAll(images);
    result.addAll(videos);

    // 应用多样性重排
    return diversifyResult(result);
}
```

---

## 四、数据存储结构设计

### 4.1 数据库表结构设计

#### 4.1.1 用户相关表

**用户表 (user)**
```sql
CREATE TABLE `user` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '用户ID',
    `username` VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    `nickname` VARCHAR(100) COMMENT '昵称',
    `avatar` VARCHAR(500) COMMENT '头像URL',
    `email` VARCHAR(100) UNIQUE COMMENT '邮箱',
    `phone` VARCHAR(20) UNIQUE COMMENT '手机号',
    `status` TINYINT DEFAULT 1 COMMENT '状态：1-正常，0-禁用',
    `register_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '注册时间',
    `last_login_time` DATETIME COMMENT '最后登录时间',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `is_deleted` TINYINT DEFAULT 0 COMMENT '是否删除：0-否，1-是',
    INDEX `idx_username` (`username`),
    INDEX `idx_email` (`email`),
    INDEX `idx_phone` (`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';
```

**用户画像表 (user_profile)**
```sql
CREATE TABLE `user_profile` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '画像ID',
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `age_range` VARCHAR(20) COMMENT '年龄段：18-24,25-34,35-44,45-54,55+',
    `gender` TINYINT COMMENT '性别：0-未知，1-男，2-女',
    `interest_tags` JSON COMMENT '兴趣标签及权重：{"科技":0.8,"娱乐":0.6}',
    `content_preference` JSON COMMENT '内容类型偏好：{"article":0.5,"image":0.3,"video":0.2}',
    `active_periods` JSON COMMENT '活跃时段：[8,12,18,22]',
    `device_preference` VARCHAR(20) COMMENT '设备偏好：mobile,pc,tablet',
    `total_read_time` INT DEFAULT 0 COMMENT '总阅读时长（分钟）',
    `total_view_count` INT DEFAULT 0 COMMENT '总浏览量',
    `last_update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '最后更新时间',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    UNIQUE KEY `uk_user_id` (`user_id`),
    INDEX `idx_interest_tags` ((CAST(interest_tags AS CHAR(255)))),
    INDEX `idx_update_time` (`last_update_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户画像表';
```

**用户行为表 (user_behavior)**
```sql
CREATE TABLE `user_behavior` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '行为ID',
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `content_type` VARCHAR(20) NOT NULL COMMENT '内容类型：article,image,video',
    `content_id` BIGINT NOT NULL COMMENT '内容ID',
    `behavior_type` TINYINT NOT NULL COMMENT '行为类型：1-浏览，2-点赞，3-收藏，4-分享，5-评论',
    `duration` INT COMMENT '停留时长（秒），仅浏览行为记录',
    `device` VARCHAR(20) COMMENT '设备类型：mobile,pc,tablet',
    `ip` VARCHAR(50) COMMENT 'IP地址',
    `extra_info` JSON COMMENT '额外信息',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '行为时间',
    INDEX `idx_user_id` (`user_id`),
    INDEX `idx_content` (`content_type`, `content_id`),
    INDEX `idx_behavior_type` (`behavior_type`),
    INDEX `idx_create_time` (`create_time`),
    INDEX `idx_user_content` (`user_id`, `content_type`, `content_id`),
    INDEX `idx_user_time` (`user_id`, `create_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户行为表';
```

#### 4.1.2 文章相关表

**文章表 (article)**
```sql
CREATE TABLE `article` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '文章ID',
    `title` VARCHAR(500) NOT NULL COMMENT '文章标题',
    `summary` VARCHAR(1000) COMMENT '文章摘要',
    `content` LONGTEXT NOT NULL COMMENT '文章内容',
    `cover_image` VARCHAR(500) COMMENT '封面图URL',
    `category_id` BIGINT COMMENT '分类ID',
    `tags` JSON COMMENT '标签：["科技","AI"]',
    `keywords` JSON COMMENT '关键词（TF-IDF提取）及权重：{"人工智能":0.9,"深度学习":0.8}',
    `author_id` BIGINT COMMENT '作者ID',
    `word_count` INT COMMENT '字数',
    `read_duration` INT COMMENT '预估阅读时长（分钟）',
    `source` VARCHAR(100) COMMENT '来源',
    `is_original` TINYINT DEFAULT 1 COMMENT '是否原创：1-是，0-否',
    `status` TINYINT DEFAULT 1 COMMENT '状态：0-草稿，1-已发布，2-下架',
    `publish_time` DATETIME COMMENT '发布时间',
    `view_count` BIGINT DEFAULT 0 COMMENT '浏览量',
    `like_count` INT DEFAULT 0 COMMENT '点赞数',
    `comment_count` INT DEFAULT 0 COMMENT '评论数',
    `collect_count` INT DEFAULT 0 COMMENT '收藏数',
    `share_count` INT DEFAULT 0 COMMENT '分享数',
    `finish_read_count` INT DEFAULT 0 COMMENT '完读数',
    `quality_score` DECIMAL(5,2) DEFAULT 0.00 COMMENT '质量得分',
    `content_vector` JSON COMMENT '内容向量（特征）',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `is_deleted` TINYINT DEFAULT 0 COMMENT '是否删除：0-否，1-是',
    INDEX `idx_category_id` (`category_id`),
    INDEX `idx_author_id` (`author_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_publish_time` (`publish_time`),
    INDEX `idx_quality_score` (`quality_score`),
    FULLTEXT INDEX `ft_title_content` (`title`, `content`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文章表';
```

**文章分类表 (article_category)**
```sql
CREATE TABLE `article_category` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '分类ID',
    `name` VARCHAR(50) NOT NULL COMMENT '分类名称',
    `parent_id` BIGINT DEFAULT 0 COMMENT '父分类ID，0表示顶级分类',
    `sort` INT DEFAULT 0 COMMENT '排序',
    `icon` VARCHAR(100) COMMENT '图标',
    `description` VARCHAR(500) COMMENT '描述',
    `status` TINYINT DEFAULT 1 COMMENT '状态：1-启用，0-禁用',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    INDEX `idx_parent_id` (`parent_id`),
    INDEX `idx_sort` (`sort`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文章分类表';
```

#### 4.1.3 图片相关表

**图片表 (image)**
```sql
CREATE TABLE `image` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '图片ID',
    `title` VARCHAR(200) COMMENT '图片标题',
    `description` VARCHAR(1000) COMMENT '图片描述',
    `url` VARCHAR(500) NOT NULL COMMENT '图片URL',
    `thumbnail_url` VARCHAR(500) COMMENT '缩略图URL',
    `width` INT COMMENT '图片宽度（像素）',
    `height` INT COMMENT '图片高度（像素）',
    `aspect_ratio` DECIMAL(5,3) COMMENT '宽高比',
    `file_size` BIGINT COMMENT '文件大小（字节）',
    `format` VARCHAR(10) COMMENT '图片格式：jpg,png,gif,webp',
    `category_id` BIGINT COMMENT '分类ID',
    `tags` JSON COMMENT '标签：["风景","日落"]',
    `keywords` JSON COMMENT '关键词及权重',
    `uploader_id` BIGINT COMMENT '上传者ID',
    `source` VARCHAR(100) COMMENT '来源',
    `color_histogram` JSON COMMENT '颜色直方图特征',
    `dominant_colors` JSON COMMENT '主色调：["#FF5733","#C70039"]',
    `visual_features` JSON COMMENT '视觉特征向量',
    `status` TINYINT DEFAULT 1 COMMENT '状态：0-待审核，1-已发布，2-下架',
    `publish_time` DATETIME COMMENT '发布时间',
    `view_count` BIGINT DEFAULT 0 COMMENT '浏览量',
    `like_count` INT DEFAULT 0 COMMENT '点赞数',
    `collect_count` INT DEFAULT 0 COMMENT '收藏数',
    `download_count` INT DEFAULT 0 COMMENT '下载次数',
    `quality_score` DECIMAL(5,2) DEFAULT 0.00 COMMENT '质量得分',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `is_deleted` TINYINT DEFAULT 0 COMMENT '是否删除：0-否，1-是',
    INDEX `idx_category_id` (`category_id`),
    INDEX `idx_uploader_id` (`uploader_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_publish_time` (`publish_time`),
    INDEX `idx_quality_score` (`quality_score`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='图片表';
```

#### 4.1.4 视频相关表

**视频表 (video)**
```sql
CREATE TABLE `video` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '视频ID',
    `title` VARCHAR(500) NOT NULL COMMENT '视频标题',
    `description` TEXT COMMENT '视频描述',
    `cover_url` VARCHAR(500) NOT NULL COMMENT '封面图URL',
    `video_url` VARCHAR(500) NOT NULL COMMENT '视频URL',
    `duration` INT NOT NULL COMMENT '视频时长（秒）',
    `width` INT COMMENT '视频宽度（像素）',
    `height` INT COMMENT '视频高度（像素）',
    `resolution` VARCHAR(20) COMMENT '分辨率：720p,1080p,4K',
    `format` VARCHAR(20) COMMENT '视频格式：mp4,avi,mov',
    `file_size` BIGINT COMMENT '文件大小（字节）',
    `category_id` BIGINT COMMENT '分类ID',
    `tags` JSON COMMENT '标签：["搞笑","生活"]',
    `keywords` JSON COMMENT '关键词及权重',
    `uploader_id` BIGINT COMMENT '上传者ID',
    `source` VARCHAR(100) COMMENT '来源',
    `keyframe_features` JSON COMMENT '关键帧特征',
    `visual_features` JSON COMMENT '视觉特征向量',
    `text_features` JSON COMMENT '文本特征向量',
    `status` TINYINT DEFAULT 1 COMMENT '状态：0-待审核，1-已发布，2-下架',
    `publish_time` DATETIME COMMENT '发布时间',
    `view_count` BIGINT DEFAULT 0 COMMENT '播放量',
    `like_count` INT DEFAULT 0 COMMENT '点赞数',
    `comment_count` INT DEFAULT 0 COMMENT '评论数',
    `collect_count` INT DEFAULT 0 COMMENT '收藏数',
    `share_count` INT DEFAULT 0 COMMENT '分享数',
    `finish_watch_count` INT DEFAULT 0 COMMENT '完播数',
    `quality_score` DECIMAL(5,2) DEFAULT 0.00 COMMENT '质量得分',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` DATETIME DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    `is_deleted` TINYINT DEFAULT 0 COMMENT '是否删除：0-否，1-是',
    INDEX `idx_category_id` (`category_id`),
    INDEX `idx_uploader_id` (`uploader_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_publish_time` (`publish_time`),
    INDEX `idx_quality_score` (`quality_score`),
    INDEX `idx_duration` (`duration`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='视频表';
```

#### 4.1.5 推荐相关表

**推荐结果缓存表 (recommend_cache)**
```sql
CREATE TABLE `recommend_cache` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT '缓存ID',
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `content_type` VARCHAR(20) COMMENT '内容类型：all,article,image,video',
    `recommend_type` VARCHAR(50) COMMENT '推荐类型：personal,popular,latest',
    `recommend_result` JSON NOT NULL COMMENT '推荐结果JSON',
    `expire_time` DATETIME NOT NULL COMMENT '过期时间',
    `create_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    INDEX `idx_user_type` (`user_id`, `content_type`, `recommend_type`),
    INDEX `idx_expire_time` (`expire_time`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='推荐结果缓存表';
```

**物品相似度表 (item_similarity)**
```sql
CREATE TABLE `item_similarity` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT COMMENT 'ID',
    `content_type` VARCHAR(20) NOT NULL COMMENT '内容类型',
    `item_id_1` BIGINT NOT NULL COMMENT '物品1的ID',
    `item_id_2` BIGINT NOT NULL COMMENT '物品2的ID',
    `similarity` DECIMAL(10,6) NOT NULL COMMENT '相似度',
    `calculate_time` DATETIME DEFAULT CURRENT_TIMESTAMP COMMENT '计算时间',
    UNIQUE KEY `uk_items` (`content_type`, `item_id_1`, `item_id_2`),
    INDEX `idx_item_1` (`content_type`, `item_id_1`),
    INDEX `idx_similarity` (`similarity`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='物品相似度表';
```

### 4.2 Redis缓存设计

#### 4.2.1 缓存结构

```java
// 1. 用户画像缓存
// Key格式: user_profile:{userId}
// 类型: Hash
// 过期时间: 1小时
// 数据结构:
user_profile:12345 -> {
    "interest_tags": "{\"科技\":0.8,\"娱乐\":0.6}",
    "content_preference": "{\"article\":0.5,\"image\":0.3,\"video\":0.2}",
    "last_update": "2026-02-15 10:00:00"
}

// 2. 推荐结果缓存
// Key格式: recommend:{userId}:{contentType}:{recommendType}
// 类型: String (JSON)
// 过期时间: 10-30分钟
// 数据结构:
recommend:12345:article:personal -> "[{\"id\":1,\"score\":0.95},{\"id\":2,\"score\":0.88}]"

// 3. 热门内容缓存
// Key格式: hot_content:{contentType}:{period}
// 类型: Sorted Set
// 过期时间: 1小时
// 数据结构:
hot_content:article:hour -> {
    "article_1": 1000,  // score为热度值
    "article_2": 800
}

// 4. 内容特征缓存
// Key格式: content_feature:{contentType}:{contentId}
// 类型: String (JSON)
// 过期时间: 24小时
// 数据结构:
content_feature:article:123 -> "{\"keywords\":{\"AI\":0.9,\"深度学习\":0.8},\"vector\":[0.1,0.2,0.3]}"

// 5. 用户行为队列（用于异步更新画像）
// Key格式: user_behavior_queue
// 类型: List
// 数据结构:
user_behavior_queue -> ["{\"userId\":123,\"type\":\"view\",\"contentId\":456}"]

// 6. 分布式锁
// Key格式: lock:{userId}:{operation}
// 类型: String
// 过期时间: 30秒
// 数据结构:
lock:123:update_profile -> "1"
```

#### 4.2.2 缓存策略

| 数据类型 | 缓存策略 | 过期时间 | 更新时机 |
|---------|---------|---------|---------|
| 用户画像 | Cache-Aside | 1小时 | 用户行为更新时 |
| 推荐结果 | Write-Through | 10-30分钟 | 每次计算后 |
| 热门内容 | Write-Behind | 1小时 | 定时任务更新 |
| 内容特征 | Cache-Aside | 24小时 | 内容更新时 |
| 相似度矩阵 | Cache-Aside | 7天 | 定时计算 |

---

## 五、性能优化措施

### 5.1 数据库优化

#### 5.1.1 索引优化

```sql
-- 复合索引设计（按查询频率和选择性排序）
-- 用户行为表查询优化
ALTER TABLE user_behavior ADD INDEX idx_user_content_time (user_id, content_type, content_id, create_time);

-- 内容表查询优化
ALTER TABLE article ADD INDEX idx_status_publish_quality (status, publish_time, quality_score);
ALTER TABLE image ADD INDEX idx_status_publish_quality (status, publish_time, quality_score);
ALTER TABLE video ADD INDEX idx_status_publish_quality (status, publish_time, quality_score);

-- 相似度查询优化
ALTER TABLE item_similarity ADD INDEX idx_type_sim (content_type, similarity DESC);
```

#### 5.1.2 分区策略

```sql
-- 用户行为表按时间分区（按月）
ALTER TABLE user_behavior PARTITION BY RANGE (TO_DAYS(create_time)) (
    PARTITION p202601 VALUES LESS THAN (TO_DAYS('2026-02-01')),
    PARTITION p202602 VALUES LESS THAN (TO_DAYS('2026-03-01')),
    PARTITION p202603 VALUES LESS THAN (TO_DAYS('2026-04-01')),
    PARTITION pmax VALUES LESS THAN MAXVALUE
);
```

#### 5.1.3 查询优化

```java
// 1. 使用MyBatis-Plus的分页插件
Page<Article> page = new Page<>(pageNum, pageSize);
LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<Article>()
    .eq(Article::getStatus, 1)
    .orderByDesc(Article::getQualityScore);
Page<Article> result = articleMapper.selectPage(page, wrapper);

// 2. 批量查询代替循环查询
List<Long> ids = recommendItems.stream().map(RecommendItem::getId).collect(Collectors.toList());
Map<Long, Article> articleMap = articleMapper.selectBatchIds(ids).stream()
    .collect(Collectors.toMap(Article::getId, Function.identity()));

// 3. 只查询需要的字段
List<ArticleDTO> articles = articleMapper.selectList(
    new QueryWrapper<Article>()
        .select("id", "title", "summary", "cover_image", "view_count", "quality_score")
        .eq("status", 1)
).stream().map(this::toDTO).collect(Collectors.toList());
```

### 5.2 缓存优化

#### 5.2.1 多级缓存

```java
@Configuration
public class CacheConfig {

    // 一级缓存：Caffeine本地缓存
    @Bean
    public Cache<String, Object> localCache() {
        return Caffeine.newBuilder()
            .maximumSize(1000)
            .expireAfterWrite(5, TimeUnit.MINUTES)
            .build();
    }

    // 二级缓存：Redis分布式缓存
    @Bean
    public RedisCacheManager redisCacheManager(RedisConnectionFactory factory) {
        RedisCacheConfiguration config = RedisCacheConfiguration.defaultCacheConfig()
            .entryTtl(Duration.ofMinutes(30))
            .serializeKeysWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new StringRedisSerializer()))
            .serializeValuesWith(RedisSerializationContext.SerializationPair
                .fromSerializer(new GenericJackson2JsonRedisSerializer()));

        return RedisCacheManager.builder(factory)
            .cacheDefaults(config)
            .build();
    }
}
```

#### 5.2.2 缓存预热

```java
@Component
public class CacheWarmup {

    @Scheduled(cron = "0 0 2 * * ?") // 每天凌晨2点执行
    public void warmupHotContent() {
        // 预热热门文章
        List<Article> hotArticles = articleMapper.selectHotArticles(100);
        hotArticles.forEach(article -> {
            String key = "article:" + article.getId();
            redisTemplate.opsForValue().set(key, article, 1, TimeUnit.HOURS);
        });

        // 预热热门图片
        List<Image> hotImages = imageMapper.selectHotImages(100);
        hotImages.forEach(image -> {
            String key = "image:" + image.getId();
            redisTemplate.opsForValue().set(key, image, 1, TimeUnit.HOURS);
        });
    }
}
```

### 5.3 并发优化

#### 5.3.1 虚拟线程（JDK 21）

```java
@Configuration
public class ThreadPoolConfig {

    @Bean("virtualThreadExecutor")
    public ExecutorService virtualThreadExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }
}

// 使用虚拟线程处理推荐任务
@Service
public class RecommendService {

    @Resource
    private ExecutorService virtualThreadExecutor;

    public RecommendResult recommend(Long userId) {
        List<CompletableFuture<List<RecommendItem>>> futures = List.of(
            CompletableFuture.supplyAsync(() -> recommendByContent(userId), virtualThreadExecutor),
            CompletableFuture.supplyAsync(() -> recommendByCF(userId), virtualThreadExecutor),
            CompletableFuture.supplyAsync(() -> recommendPopular(userId), virtualThreadExecutor)
        );

        // 等待所有任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 合并结果
        List<RecommendItem> result = futures.stream()
            .flatMap(future -> future.join().stream())
            .collect(Collectors.toList());

        return mergeAndRank(result);
    }
}
```

#### 5.3.2 异步处理

```java
@Service
public class UserBehaviorService {

    @Async("taskExecutor")
    public void updateUserProfileAsync(Long userId) {
        // 异步更新用户画像
        UserProfile profile = calculateUserProfile(userId);
        userProfileMapper.updateById(profile);

        // 清除相关缓存
        redisTemplate.delete("user_profile:" + userId);
    }

    // 用户行为记录时触发异步更新
    public void recordBehavior(UserBehavior behavior) {
        userBehaviorMapper.insert(behavior);

        // 异步更新用户画像
        updateUserProfileAsync(behavior.getUserId());
    }
}
```

### 5.4 算法优化

#### 5.4.1 向量相似度计算优化

```java
// 使用稀疏向量减少计算量
public class SparseVector {

    private Map<Integer, Double> data; // 只存储非零元素

    // 余弦相似度计算（优化版）
    public double cosineSimilarity(SparseVector other) {
        Set<Integer> commonKeys = new HashSet<>(data.keySet());
        commonKeys.retainAll(other.data.keySet());

        double dotProduct = commonKeys.stream()
            .mapToDouble(key -> data.get(key) * other.data.get(key))
            .sum();

        double norm1 = Math.sqrt(data.values().stream()
            .mapToDouble(v -> v * v).sum());
        double norm2 = Math.sqrt(other.data.values().stream()
            .mapToDouble(v -> v * v).sum());

        return dotProduct / (norm1 * norm2);
    }
}

// 批量计算相似度（向量化计算）
public List<SimilarityResult> batchCalculateSimilarity(
    Map<Long, SparseVector> itemVectors,
    SparseVector targetVector,
    int topK
) {
    return itemVectors.entrySet().parallelStream()
        .map(entry -> new SimilarityResult(
            entry.getKey(),
            entry.getValue().cosineSimilarity(targetVector)
        ))
        .sorted(Comparator.comparing(SimilarityResult::getScore).reversed())
        .limit(topK)
        .collect(Collectors.toList());
}
```

#### 5.4.2 候选集召回优化

```java
// 多路召回 + 合并
public List<Long> recallCandidates(Long userId) {
    List<Long> candidates = new ArrayList<>();

    // 路由召回：基于用户画像快速筛选
    candidates.addAll(recallByTags(userId, 200));

    // 协同过滤召回
    candidates.addAll(recallByCollaborativeFiltering(userId, 200));

    // 热门召回
    candidates.addAll(recallHot(100));

    // 去重
    Set<Long> uniqueCandidates = new LinkedHashSet<>(candidates);

    return new ArrayList<>(uniqueCandidates);
}

// 使用布隆过滤器快速判断用户是否已阅读
public class BloomFilterService {

    private BloomFilter<Long> readFilter;

    public void initReadFilter() {
        // 初始化布隆过滤器（预计1000万条数据，误判率0.01%）
        readFilter = BloomFilter.create(
            Funnels.longFunnel(),
            10_000_000,
            0.0001
        );
    }

    public boolean isRead(Long contentId) {
        return readFilter.mightContain(contentId);
    }
}
```

### 5.5 连接池优化

```yaml
# application.yml
spring:
  datasource:
    hikari:
      # 连接池大小 = (核心数 * 2) + 磁盘数
      maximum-pool-size: 20
      minimum-idle: 10
      # 连接最大存活时间
      max-lifetime: 1800000
      # 连接超时时间
      connection-timeout: 30000
      # 空闲连接超时
      idle-timeout: 600000
      # 连接测试查询
      connection-test-query: SELECT 1
      # 泄漏检测阈值
      leak-detection-threshold: 60000

  data:
    redis:
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5
          max-wait: 3000ms
```

---

## 六、测试方案

### 6.1 测试策略

#### 6.1.1 单元测试

```java
@SpringBootTest
class RecommendServiceTest {

    @Resource
    private RecommendService recommendService;

    @Test
    void testRecommendByTags() {
        // 准备测试数据
        Long userId = 1L;

        // 执行推荐
        RecommendResult result = recommendService.recommendByTags(userId, 10);

        // 断言
        assertNotNull(result);
        assertEquals(10, result.getItems().size());
        result.getItems().forEach(item -> {
            assertNotNull(item.getContentId());
            assertTrue(item.getScore() >= 0 && item.getScore() <= 1);
        });
    }

    @Test
    void testCalculateSimilarity() {
        // 测试相似度计算
        Map<String, Double> vector1 = Map.of("AI", 0.9, "科技", 0.7);
        Map<String, Double> vector2 = Map.of("AI", 0.8, "科技", 0.6);

        double similarity = SimilarityCalculator.cosineSimilarity(vector1, vector2);

        assertTrue(similarity > 0.9); // 应该很相似
    }
}
```

#### 6.1.2 集成测试

```java
@SpringBootTest
@AutoConfigureMockMvc
class RecommendControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    void testRecommendAPI() throws Exception {
        mockMvc.perform(post("/api/recommend")
                .contentType(MediaType.APPLICATION_JSON)
                .content("{\"userId\":1,\"contentType\":\"article\",\"limit\":10}"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.code").value(200))
            .andExpect(jsonPath("$.data.items").isArray())
            .andExpect(jsonPath("$.data.items.length()").value(10));
    }
}
```

#### 6.1.3 性能测试

```java
// 使用JMeter进行性能测试
// 测试场景：1000并发用户请求推荐接口
// 预期指标：
// - QPS: 500+
// - 响应时间: P95 < 200ms, P99 < 500ms
// - 错误率: < 0.1%

// 或使用Spring Boot Test进行简单性能测试
@Test
void performanceTest() {
    int threadCount = 100;
    int requestsPerThread = 10;

    long startTime = System.currentTimeMillis();

    ExecutorService executor = Executors.newFixedThreadPool(threadCount);
    CountDownLatch latch = new CountDownLatch(threadCount);

    for (int i = 0; i < threadCount; i++) {
        executor.submit(() -> {
            try {
                for (int j = 0; j < requestsPerThread; j++) {
                    recommendService.recommend(1L);
                }
            } finally {
                latch.countDown();
            }
        });
    }

    latch.await();
    executor.shutdown();

    long endTime = System.currentTimeMillis();
    long duration = endTime - startTime;
    int totalRequests = threadCount * requestsPerThread;
    double qps = totalRequests * 1000.0 / duration;

    System.out.println("Total requests: " + totalRequests);
    System.out.println("Duration: " + duration + "ms");
    System.out.println("QPS: " + qps);
}
```

#### 6.1.4 算法准确性测试

```java
@Test
void testRecommendAccuracy() {
    // 准备测试数据：用户历史行为
    Long userId = 1L;
    List<Long> historyItemIds = userBehaviorMapper.selectHistoryItemIds(userId);

    // 获取推荐结果
    RecommendResult result = recommendService.recommend(userId);

    // 计算命中率：推荐结果中与历史相似的占比
    int hitCount = 0;
    for (RecommendItem item : result.getItems()) {
        if (isSimilarToHistory(item.getContentId(), historyItemIds)) {
            hitCount++;
        }
    }

    double hitRate = (double) hitCount / result.getItems().size();
    System.out.println("Hit rate: " + hitRate);

    // 命中率应该 > 30%
    assertTrue(hitRate > 0.3);
}
```

### 6.2 测试覆盖率目标

| 模块 | 单元测试覆盖率 | 集成测试覆盖率 |
|-----|--------------|--------------|
| Controller层 | 70% | 80% |
| Service层 | 85% | 60% |
| Algorithm层 | 90% | 40% |
| Mapper层 | 60% | 80% |
| 整体 | 75% | 65% |

### 6.3 压力测试方案

```bash
# 使用Apache Bench (ab)
ab -n 10000 -c 100 -p request.json -T application/json http://localhost:8080/api/recommend

# 或使用wrk
wrk -t12 -c400 -d30s http://localhost:8080/api/recommend

# 预期目标：
# - 并发用户：100-500
# - QPS：300-500
# - 平均响应时间：< 100ms
# - P99响应时间：< 500ms
# - 错误率：< 0.1%
```

---

## 七、部署策略

### 7.1 部署架构

```
┌─────────────────────────────────────────────────────────┐
│                       负载均衡层                          │
│                    Nginx / SLB                           │
└────────────────────┬────────────────────────────────────┘
                     │
        ┌────────────┼────────────┐
        │            │            │
┌───────▼──────┐ ┌──▼──────────┐ ┌▼───────────┐
│  应用实例1    │ │  应用实例2   │ │ 应用实例3   │
│  (JDK 21)    │ │  (JDK 21)   │ │ (JDK 21)   │
└───┬───────┬──┘ └──┬──────────┘ └┬───────────┘
    │       │       │            │
┌───▼───────▼───────▼────────────▼───────────┐
│              MySQL 主从复制                  │
│         ┌────────┐      ┌────────┐         │
│         │ Master │ ◄───►│ Slave  │         │
│         └────────┘      └────────┘         │
└─────────────────────────────────────────────┘
┌─────────────────────────────────────────────┐
│              Redis 集群                      │
│         ┌────────┐      ┌────────┐         │
│         │ Master │ ◄───►│ Slave  │         │
│         └────────┘      └────────┘         │
└─────────────────────────────────────────────┘
```

### 7.2 部署方式

#### 7.2.1 Docker部署

**Dockerfile**
```dockerfile
FROM eclipse-temurin:21-jre-alpine

LABEL maintainer="dev@qoobot.com"

# 设置工作目录
WORKDIR /app

# 复制应用JAR
COPY target/openrecommend-1.0.0-SNAPSHOT.jar app.jar

# 设置时区
RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone && \
    apk del tzdata

# 创建日志目录
RUN mkdir -p /app/logs

# 暴露端口
EXPOSE 8080

# JVM参数优化
ENV JAVA_OPTS="-XX:+UseZGC -XX:+UnlockExperimentalVMOptions -Xms2g -Xmx2g -XX:MaxGCPauseMillis=200"

# 启动应用
ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

**docker-compose.yml**
```yaml
version: '3.8'

services:
  # MySQL
  mysql:
    image: mysql:8.4
    container_name: openrecommend-mysql
    environment:
      MYSQL_ROOT_PASSWORD: root123456
      MYSQL_DATABASE: openrecommend
    ports:
      - "3306:3306"
    volumes:
      - mysql-data:/var/lib/mysql
      - ./sql/init.sql:/docker-entrypoint-initdb.d/init.sql
    command:
      - --character-set-server=utf8mb4
      - --collation-server=utf8mb4_unicode_ci
    networks:
      - openrecommend-network

  # Redis
  redis:
    image: redis:7-alpine
    container_name: openrecommend-redis
    ports:
      - "6379:6379"
    volumes:
      - redis-data:/data
    command: redis-server --appendonly yes
    networks:
      - openrecommend-network

  # 应用
  app:
    build: .
    container_name: openrecommend-app
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - redis
    environment:
      SPRING_DATASOURCE_URL: jdbc:mysql://mysql:3306/openrecommend?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai
      SPRING_DATASOURCE_USERNAME: root
      SPRING_DATASOURCE_PASSWORD: root123456
      SPRING_REDIS_HOST: redis
      SPRING_REDIS_PORT: 6379
    volumes:
      - ./logs:/app/logs
    networks:
      - openrecommend-network

volumes:
  mysql-data:
  redis-data:

networks:
  openrecommend-network:
    driver: bridge
```

#### 7.2.2 Kubernetes部署

**deployment.yaml**
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: openrecommend
  labels:
    app: openrecommend
spec:
  replicas: 3
  selector:
    matchLabels:
      app: openrecommend
  template:
    metadata:
      labels:
        app: openrecommend
    spec:
      containers:
      - name: openrecommend
        image: openrecommend:1.0.0
        ports:
        - containerPort: 8080
        env:
        - name: SPRING_PROFILES_ACTIVE
          value: "prod"
        - name: SPRING_DATASOURCE_URL
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: url
        - name: SPRING_DATASOURCE_USERNAME
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: username
        - name: SPRING_DATASOURCE_PASSWORD
          valueFrom:
            secretKeyRef:
              name: mysql-secret
              key: password
        - name: SPRING_REDIS_HOST
          value: "redis-service"
        - name: SPRING_REDIS_PORT
          value: "6379"
        resources:
          requests:
            memory: "2Gi"
            cpu: "1000m"
          limits:
            memory: "4Gi"
            cpu: "2000m"
        livenessProbe:
          httpGet:
            path: /actuator/health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 10
        readinessProbe:
          httpGet:
            path: /actuator/health/readiness
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 5

---
apiVersion: v1
kind: Service
metadata:
  name: openrecommend-service
spec:
  selector:
    app: openrecommend
  ports:
  - protocol: TCP
    port: 80
    targetPort: 8080
  type: LoadBalancer
```

### 7.3 配置管理

**application-prod.yml**
```yaml
server:
  port: 8080

spring:
  application:
    name: openrecommend

  datasource:
    url: jdbc:mysql://${MYSQL_HOST:localhost}:${MYSQL_PORT:3306}/${MYSQL_DATABASE:openrecommend}?useUnicode=true&characterEncoding=utf8&useSSL=false&serverTimezone=Asia/Shanghai&rewriteBatchedStatements=true
    username: ${MYSQL_USERNAME:root}
    password: ${MYSQL_PASSWORD:root123456}
    driver-class-name: com.mysql.cj.jdbc.Driver
    hikari:
      maximum-pool-size: 20
      minimum-idle: 10
      max-lifetime: 1800000
      connection-timeout: 30000

  data:
    redis:
      host: ${REDIS_HOST:localhost}
      port: ${REDIS_PORT:6379}
      password: ${REDIS_PASSWORD:}
      database: 0
      lettuce:
        pool:
          max-active: 20
          max-idle: 10
          min-idle: 5

mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    cache-enabled: true
  global-config:
    db-config:
      logic-delete-field: isDeleted
      logic-delete-value: 1
      logic-not-delete-value: 0

# 推荐配置
recommend:
  # 召回策略配置
  recall:
    content-count: 200
    cf-count: 200
    hot-count: 100
  # 排序配置
  ranking:
    candidate-size: 1000
    result-size: 20
  # 缓存配置
  cache:
    user-profile-ttl: 3600
    recommend-result-ttl: 1800
    hot-content-ttl: 3600

# 日志配置
logging:
  level:
    root: INFO
    com.qoobot.openrecommend: DEBUG
  file:
    name: /app/logs/openrecommend.log
    max-size: 100MB
    max-history: 30

# 监控配置
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus
  endpoint:
    health:
      probes:
        enabled: true
```

### 7.4 监控与日志

**Actuator监控端点**
```yaml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,heapdump,threaddump
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: ${spring.application.name}
```

**日志收集 (ELK Stack)**
```yaml
# logback-spring.xml
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>/app/logs/openrecommend.log</file>
        <encoder class="net.logstash.logback.encoder.LogstashEncoder"/>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>/app/logs/openrecommend.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
        </rollingPolicy>
    </appender>

    <root level="INFO">
        <appender-ref ref="FILE"/>
    </root>
</configuration>
```

### 7.5 发布流程

```
1. 代码提交 → 2. CI构建 → 3. 单元测试 → 4. 代码扫描 → 5. 构建Docker镜像
     ↓
6. 推送镜像仓库 → 7. 部署到测试环境 → 8. 集成测试 → 9. 性能测试
     ↓
10. 审批 → 11. 灰度发布（10%） → 12. 观察监控 → 13. 逐步放量（50%→100%）
     ↓
14. 全量发布 → 15. 监控告警
```

---

## 八、开发计划时间表

### 8.1 总体时间安排（10周）

| 阶段 | 时间 | 主要任务 | 交付物 |
|-----|------|---------|-------|
| 第一阶段 | 第1-2周 | 项目搭建与基础功能 | 项目骨架、数据库设计 |
| 第二阶段 | 第3-4周 | 内容管理模块 | 文章/图片/视频CRUD |
| 第三阶段 | 第5-6周 | 推荐算法实现 | 各类型推荐器 |
| 第四阶段 | 第7周 | 用户画像与行为 | 画像更新、行为记录 |
| 第五阶段 | 第8周 | 性能优化 | 缓存、并发优化 |
| 第六阶段 | 第9周 | 测试与修复 | 单元测试、集成测试 |
| 第七阶段 | 第10周 | 部署与上线 | 部署文档、监控配置 |

### 8.2 详细周计划

#### 第1周：项目搭建
- [ ] 创建Maven项目结构
- [ ] 配置Spring Boot + MyBatis-Plus
- [ ] 设计并创建数据库表
- [ ] 实现基础实体类和Mapper
- [ ] 配置Redis连接
- [ ] 编写配置文件（dev/test/prod）
- [ ] 实现统一响应格式和异常处理

**里程碑1**: 项目骨架搭建完成，数据库表创建完成

#### 第2周：基础功能开发
- [ ] 实现用户注册/登录
- [ ] 实现用户管理功能
- [ ] 实现文章CRUD接口
- [ ] 实现图片CRUD接口
- [ ] 实现视频CRUD接口
- [ ] 实现内容搜索功能
- [ ] 编写单元测试

**里程碑2**: 内容管理基础功能完成

#### 第3周：推荐算法 - 文章推荐
- [ ] 实现TF-IDF关键词提取
- [ ] 实现文本向量化
- [ ] 实现余弦相似度计算
- [ ] 实现文章推荐器
- [ ] 实现热门文章推荐
- [ ] 实现相关文章推荐
- [ ] 编写算法单元测试

**里程碑3**: 文章推荐算法完成

#### 第4周：推荐算法 - 图片/视频推荐
- [ ] 实现图片视觉特征提取
- [ ] 实现颜色直方图计算
- [ ] 实现图片推荐器
- [ ] 实现视频封面特征提取
- [ ] 实现视频多特征融合
- [ ] 实现视频推荐器
- [ ] 编写算法单元测试

**里程碑4**: 图片/视频推荐算法完成

#### 第5周：协同过滤与混合推荐
- [ ] 实现用户相似度计算
- [ ] 实现物品相似度计算
- [ ] 实现User-based CF
- [ ] 实现Item-based CF
- [ ] 实现混合推荐策略
- [ ] 实现多样性处理
- [ ] 编写算法单元测试

**里程碑5**: 协同过滤与混合推荐完成

#### 第6周：用户画像与行为系统
- [ ] 实现用户行为记录
- [ ] 实现用户画像计算
- [ ] 实现画像更新机制
- [ ] 实现兴趣标签提取
- [ ] 实现内容偏好计算
- [ ] 异步更新画像
- [ ] 编写单元测试

**里程碑6**: 用户画像与行为系统完成

#### 第7周：推荐引擎整合
- [ ] 实现候选集召回
- [ ] 实现特征计算服务
- [ ] 实现排序打分
- [ ] 实现推荐结果缓存
- [ ] 实现跨内容类型推荐
- [ ] 优化推荐性能
- [ ] 编写集成测试

**里程碑7**: 推荐引擎整合完成

#### 第8周：性能优化
- [ ] 实现Redis多级缓存
- [ ] 实现缓存预热
- [ ] 优化数据库查询
- [ ] 实现虚拟线程并发处理
- [ ] 优化算法计算性能
- [ ] 实现批量操作
- [ ] 性能测试与调优

**里程碑8**: 性能优化完成，QPS达到300+

#### 第9周：测试
- [ ] 完善单元测试（覆盖率>75%）
- [ ] 编写集成测试
- [ ] 编写性能测试脚本
- [ ] 算法准确性测试
- [ ] 修复测试发现的问题
- [ ] 压力测试
- [ ] 测试报告

**里程碑9**: 测试完成，测试覆盖率达标

#### 第10周：部署与文档
- [ ] 编写Dockerfile
- [ ] 编写docker-compose.yml
- [ ] 编写部署文档
- [ ] 配置监控告警
- [ ] 部署到测试环境
- [ ] 部署到生产环境
- [ ] 编写API文档

**里程碑10**: 系统上线，文档完善

### 8.3 关键里程碑

| 里程碑 | 时间点 | 验收标准 |
|-------|-------|---------|
| M1: 项目搭建完成 | 第1周末 | 项目可正常启动，数据库表创建完成 |
| M2: 内容管理完成 | 第2周末 | 文章/图片/视频CRUD功能可用 |
| M3: 文章推荐完成 | 第3周末 | 文章推荐准确率>30% |
| M4: 全部推荐算法完成 | 第4周末 | 三种内容类型推荐均可用 |
| M5: 混合推荐完成 | 第5周末 | 混合推荐可用，多样性处理正常 |
| M6: 用户画像完成 | 第6周末 | 用户画像自动更新正常 |
| M7: 推荐引擎完成 | 第7周末 | 完整推荐流程可用，响应时间<1s |
| M8: 性能优化完成 | 第8周末 | QPS>300，P95<200ms |
| M9: 测试完成 | 第9周末 | 单元测试覆盖率>75% |
| M10: 系统上线 | 第10周末 | 生产环境正常运行 |

---

## 九、风险评估与应对

### 9.1 技术风险

| 风险 | 影响 | 概率 | 应对措施 |
|-----|------|------|---------|
| 推荐算法效果不佳 | 高 | 中 | 1. 提前进行小规模测试<br>2. 准备多种算法备选方案<br>3. 持续收集反馈优化 |
| 数据库性能瓶颈 | 高 | 中 | 1. 合理设计索引<br>2. 实现多级缓存<br>3. 考虑分库分表 |
| Redis宕机 | 中 | 低 | 1. 配置Redis持久化<br>2. 实现降级方案<br>3. 考虑Redis集群 |
| 内存溢出 | 高 | 低 | 1. 优化JVM参数<br>2. 实现流式处理<br>3. 监控内存使用 |

### 9.2 进度风险

| 风险 | 影响 | 概率 | 应对措施 |
|-----|------|------|---------|
| 开发延期 | 高 | 中 | 1. 合理分配任务<br>2. 每周进度检查<br>3. 必要时调整优先级 |
| 测试时间不足 | 中 | 中 | 1. 并行开发测试<br>2. 提前准备测试用例<br>3. 自动化测试 |
| 需求变更 | 高 | 中 | 1. 明确需求边界<br>2. 控制变更范围<br>3. 评估变更影响 |

---

## 十、总结

本开发计划基于Spring Boot 3.5.10 + MyBatis-Plus 3.5.5 + MySQL 8.0 + JDK 21技术栈，设计了一个功能完善、架构清晰的单体应用推荐系统。计划包含：

1. **完整的系统架构**：分层清晰、模块独立
2. **实用的推荐算法**：基于内容、协同过滤、混合推荐
3. **多内容类型支持**：文章、图片、视频三种类型
4. **详细的数据库设计**：覆盖用户、内容、行为、推荐等核心表
5. **全面的性能优化**：缓存、并发、算法等多维度优化
6. **完善的测试方案**：单元、集成、性能测试
7. **清晰的部署策略**：Docker + Kubernetes

开发周期为10周，分为7个阶段，包含明确的里程碑和验收标准。技术组件协同工作方式清晰，各模块接口明确，可有效降低开发风险，确保项目按时高质量交付。
