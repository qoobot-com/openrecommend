# 技术设计文档

## 文档信息

| 项目 | 内容 |
|-----|------|
| 文档名称 | OpenRecommend 技术设计文档 |
| 版本 | 1.0.0 |
| 编写日期 | 2026-02-15 |
| 项目名称 | 多内容类型智能推荐系统 |

---

## 一、技术架构

### 1.1 总体架构

采用**单体应用 + 分层架构**设计：

```
┌─────────────────────────────────────────────────────────┐
│                    表现层 (Presentation)                   │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐   │
│  │ REST API     │  │ Filter       │  │ Interceptor  │   │
│  │ (WebMVC)     │  │ (Auth/Log)   │  │ (RateLimit)  │   │
│  └──────────────┘  └──────────────┘  └──────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                   业务层 (Business)                      │
│  ┌────────────────────────────────────────────────────┐ │
│  │              推荐引擎模块                          │ │
│  │  ContentBasedRecommender | CollaborativeFiltering  │ │
│  │  HybridRecommender | UserProfileService           │ │
│  └────────────────────────────────────────────────────┘ │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ 内容服务     │  │ 用户服务     │  │ 行为服务     │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                  持久层 (Persistence)                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ MyBatis-Plus │  │ Redis       │  │ CacheAside  │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
┌────────────────────▼────────────────────────────────────┐
│                  数据层 (Data)                            │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐   │
│  │ MySQL 8.0   │  │ Redis 7.x   │  │ FileStorage │   │
│  └─────────────┘  └─────────────┘  └─────────────┘   │
└─────────────────────────────────────────────────────────┘
```

### 1.2 技术选型

| 技术领域 | 选型 | 版本 | 选择理由 |
|---------|------|------|---------|
| 应用框架 | Spring Boot | 3.5.10 | 成熟稳定，生态丰富 |
| Web框架 | Spring WebMVC | 3.5.10 | RESTful API开发 |
| 持久层 | MyBatis-Plus | 3.5.5 | 简化ORM操作，支持代码生成 |
| 数据库 | MySQL | 8.4.0 | 成熟可靠，支持JSON字段 |
| 缓存 | Redis | 7.x | 高性能，支持丰富数据结构 |
| 运行环境 | JDK | 21 | 虚拟线程，性能提升 |
| JSON处理 | Jackson | 2.16.0 | Spring Boot默认 |
| 工具库 | Hutool | 5.8.23 | 简化开发 |
| 参数校验 | Hibernate Validator | 8.0.3 | 标准JSR-303实现 |

### 1.3 技术特性

- **虚拟线程**: 充分利用JDK 21虚拟线程，提升并发性能
- **多级缓存**: Caffeine本地缓存 + Redis分布式缓存
- **异步处理**: CompletableFuture + 虚拟线程实现异步计算
- **分库分表**: 预留分库分表能力
- **读写分离**: 支持主从数据库读写分离

---

## 二、核心模块设计

### 2.1 推荐引擎模块

#### 2.1.1 模块架构

```
RecommendEngine
├── RecallStrategy          # 召回策略
│   ├── ContentRecall       # 内容召回
│   ├── CollaborativeRecall # 协同过滤召回
│   ├── HotRecall           # 热门召回
│   └── LatestRecall        # 新品召回
├── FeatureExtractor        # 特征提取器
│   ├── TextFeature         # 文本特征
│   ├── VisualFeature       # 视觉特征
│   └── MetadataFeature     # 元数据特征
├── ScoringModel            # 评分模型
│   ├── PersonalScorer     # 个性化评分
│   ├── QualityScorer      # 质量评分
│   └── PopularityScorer    # 热度评分
├── Ranker                  # 排序器
│   ├── ScoreRanker         # 评分排序
│   └── Diversifier         # 多样性处理
└── Recommender             # 推荐器
    ├── ArticleRecommender  # 文章推荐器
    ├── ImageRecommender    # 图片推荐器
    └── VideoRecommender    # 视频推荐器
```

#### 2.1.2 召回策略实现

```java
public interface RecallStrategy {
    /**
     * 召回候选集
     */
    List<Long> recall(RecallContext context);
}

@Component
public class ContentRecallStrategy implements RecallStrategy {

    @Override
    public List<Long> recall(RecallContext context) {
        UserProfile profile = context.getUserProfile();
        Set<String> tags = profile.getInterestTags().keySet();

        // 根据标签召回
        List<Long> candidates = new ArrayList<>();
        candidates.addAll(recallByTags(context.getContentType(), tags, 200));
        candidates.addAll(recallByCategory(context.getContentType(), profile.getCategoryPreference(), 100));

        return candidates;
    }

    private List<Long> recallByTags(String contentType, Set<String> tags, int limit) {
        // 实现基于标签的召回
        return switch (contentType) {
            case "article" -> articleMapper.selectByTags(tags, limit).stream()
                .map(Article::getId).toList();
            case "image" -> imageMapper.selectByTags(tags, limit).stream()
                .map(Image::getId).toList();
            case "video" -> videoMapper.selectByTags(tags, limit).stream()
                .map(Video::getId).toList();
            default -> List.of();
        };
    }
}

@Component
public class CollaborativeRecallStrategy implements RecallStrategy {

    @Override
    public List<Long> recall(RecallContext context) {
        Long userId = context.getUserId();
        String contentType = context.getContentType();

        // 找到相似用户
        List<Long> similarUsers = findSimilarUsers(userId, 50);

        // 召回相似用户喜欢的内容
        Set<Long> candidates = new HashSet<>();
        for (Long similarUser : similarUsers) {
            candidates.addAll(getUserLikedItems(similarUser, contentType, 10));
        }

        return new ArrayList<>(candidates);
    }

    private List<Long> findSimilarUsers(Long userId, int topK) {
        // 实现用户相似度计算
        return userSimilarityService.findSimilarUsers(userId, topK);
    }
}

@Component
public class HotRecallStrategy implements RecallStrategy {

    @Override
    public List<Long> recall(RecallContext context) {
        String contentType = context.getContentType();
        return cacheService.getHotContent(contentType, 100);
    }
}
```

#### 2.1.3 特征提取实现

```java
@Component
public class FeatureExtractor {

    /**
     * 提取文章特征
     */
    public ArticleFeature extractArticleFeature(Long articleId) {
        Article article = articleMapper.selectById(articleId);

        return ArticleFeature.builder()
            .id(articleId)
            .keywords(extractKeywords(article))
            .tags(article.getTags())
            .categoryId(article.getCategoryId())
            .qualityScore(article.getQualityScore())
            .publishTime(article.getPublishTime())
            .wordCount(article.getWordCount())
            .build();
    }

    /**
     * TF-IDF关键词提取
     */
    private Map<String, Double> extractKeywords(Article article) {
        // 1. 分词
        String text = article.getTitle() + " " + article.getSummary() + " " + article.getContent();
        List<String> words = segment(text);

        // 2. 计算TF-IDF
        Map<String, Double> tfidf = tfIdfCalculator.calculate(text);

        // 3. 返回top 20
        return tfidf.entrySet().stream()
            .sorted(Map.Entry.<String, Double>comparingByValue().reversed())
            .limit(20)
            .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
    }

    /**
     * 提取图片视觉特征
     */
    public ImageFeature extractImageFeature(Long imageId) {
        Image image = imageMapper.selectById(imageId);

        return ImageFeature.builder()
            .id(imageId)
            .visualFeatures(extractVisualFeatures(image))
            .dominantColors(image.getDominantColors())
            .tags(image.getTags())
            .categoryId(image.getCategoryId())
            .qualityScore(image.getQualityScore())
            .build();
    }

    private Map<String, Double> extractVisualFeatures(Image image) {
        // 简化版：使用颜色直方图
        return ColorHistogramExtractor.extract(image.getUrl());
    }
}
```

#### 2.1.4 评分模型实现

```java
@Component
public class PersonalScorer {

    /**
     * 计算个性化得分
     */
    public double score(ContentFeature feature, UserProfile profile) {
        // 1. 标签匹配得分
        double tagScore = calculateTagScore(feature, profile);

        // 2. 分类匹配得分
        double categoryScore = calculateCategoryScore(feature, profile);

        // 3. 内容类型偏好得分
        double contentTypeScore = calculateContentTypeScore(feature, profile);

        // 加权综合
        return 0.5 * tagScore + 0.3 * categoryScore + 0.2 * contentTypeScore;
    }

    private double calculateTagScore(ContentFeature feature, UserProfile profile) {
        Map<String, Double> userTags = profile.getInterestTags();
        List<String> itemTags = feature.getTags();

        if (itemTags == null || itemTags.isEmpty()) {
            return 0.0;
        }

        double score = 0.0;
        for (String tag : itemTags) {
            if (userTags.containsKey(tag)) {
                score += userTags.get(tag);
            }
        }

        return score / itemTags.size();
    }
}

@Component
public class QualityScorer {

    /**
     * 计算质量得分
     */
    public double score(ContentFeature feature) {
        return feature.getQualityScore() / 100.0;
    }
}

@Component
public class PopularityScorer {

    /**
     * 计算热度得分
     */
    public double score(Long contentId, String contentType) {
        // 从缓存或数据库获取互动数据
        InteractionData data = getInteractionData(contentId, contentType);

        // 综合计算热度
        double score = Math.log(data.getViewCount() + 1) * 0.5 +
                       Math.log(data.getLikeCount() + 1) * 0.3 +
                       Math.log(data.getCommentCount() + 1) * 0.2;

        return Math.min(score / 10.0, 1.0);
    }
}
```

#### 2.1.5 排序与多样性处理

```java
@Component
public class RankingEngine {

    @Resource
    private PersonalScorer personalScorer;
    @Resource
    private QualityScorer qualityScorer;
    @Resource
    private PopularityScorer popularityScorer;

    /**
     * 排序
     */
    public List<RecommendItem> rank(List<RecommendItem> candidates, UserProfile profile) {
        // 并行计算各项得分
        candidates.parallelStream().forEach(item -> {
            ContentFeature feature = featureExtractor.extract(item.getContentId());

            double personalScore = personalScorer.score(feature, profile);
            double qualityScore = qualityScorer.score(feature);
            double popularityScore = popularityScorer.score(item.getContentId(), item.getContentType());
            double freshnessScore = calculateFreshnessScore(feature.getPublishTime());

            // 动态权重
            Map<String, Double> weights = calculateWeights(profile);

            double finalScore = weights.get("personal") * personalScore +
                               weights.get("quality") * qualityScore +
                               weights.get("popularity") * popularityScore +
                               weights.get("freshness") * freshnessScore;

            item.setScore(finalScore);
        });

        // 按得分排序
        return candidates.stream()
            .sorted(Comparator.comparing(RecommendItem::getScore).reversed())
            .collect(Collectors.toList());
    }

    /**
     * 多样性处理
     */
    public List<RecommendItem> diversify(List<RecommendItem> items, int limit) {
        // 使用MMR（Maximal Marginal Relevance）算法
        List<RecommendItem> result = new ArrayList<>();
        Set<String> selectedCategories = new HashSet<>();

        for (RecommendItem item : items) {
            if (result.size() >= limit) break;

            String category = getCategory(item.getContentId());

            // 控制同一分类的占比（不超过30%）
            if (selectedCategories.contains(category) &&
                countCategory(result, category) >= limit * 0.3) {
                continue;
            }

            result.add(item);
            selectedCategories.add(category);
        }

        return result;
    }
}
```

### 2.2 用户画像模块

#### 2.2.1 用户画像计算

```java
@Component
public class UserProfileCalculator {

    /**
     * 计算用户画像
     */
    public UserProfile calculate(Long userId) {
        // 获取用户近期行为
        List<UserBehavior> behaviors = userBehaviorMapper.selectRecentBehaviors(userId, 30);

        return UserProfile.builder()
            .userId(userId)
            .interestTags(calculateInterestTags(behaviors))
            .contentPreference(calculateContentPreference(behaviors))
            .categoryPreference(calculateCategoryPreference(behaviors))
            .activePeriods(calculateActivePeriods(behaviors))
            .totalViewCount(behaviors.size())
            .build();
    }

    /**
     * 计算兴趣标签
     */
    private Map<String, Double> calculateInterestTags(List<UserBehavior> behaviors) {
        Map<String, Integer> tagFrequency = new HashMap<>();
        Map<String, Integer> tagTotal = new HashMap<>();

        for (UserBehavior behavior : behaviors) {
            Content content = getContent(behavior.getContentType(), behavior.getContentId());
            if (content != null && content.getTags() != null) {
                for (String tag : content.getTags()) {
                    int weight = getBehaviorWeight(behavior.getBehaviorType());
                    tagFrequency.merge(tag, weight, Integer::sum);
                    tagTotal.merge(tag, 1, Integer::sum);
                }
            }
        }

        // 计算标签权重
        Map<String, Double> tags = new HashMap<>();
        tagFrequency.forEach((tag, freq) -> {
            double score = (double) freq / tagTotal.get(tag);
            tags.put(tag, score);
        });

        // 归一化并返回top 20
        return normalizeTags(tags, 20);
    }

    /**
     * 计算内容类型偏好
     */
    private Map<String, Double> calculateContentPreference(List<UserBehavior> behaviors) {
        Map<String, Integer> typeCount = new HashMap<>();
        int total = 0;

        for (UserBehavior behavior : behaviors) {
            int weight = getBehaviorWeight(behavior.getBehaviorType());
            typeCount.merge(behavior.getContentType(), weight, Integer::sum);
            total += weight;
        }

        Map<String, Double> preference = new HashMap<>();
        typeCount.forEach((type, count) -> {
            preference.put(type, (double) count / total);
        });

        return preference;
    }

    /**
     * 计算活跃时段
     */
    private List<Integer> calculateActivePeriods(List<UserBehavior> behaviors) {
        Map<Integer, Integer> hourCount = new HashMap<>();

        for (UserBehavior behavior : behaviors) {
            int hour = behavior.getCreateTime().getHour();
            hourCount.merge(hour, 1, Integer::sum);
        }

        // 返回活跃时段top 4
        return hourCount.entrySet().stream()
            .sorted(Map.Entry.<Integer, Integer>comparingByValue().reversed())
            .limit(4)
            .map(Map.Entry::getKey)
            .collect(Collectors.toList());
    }

    private int getBehaviorWeight(Integer behaviorType) {
        return switch (behaviorType) {
            case 1 -> 1;  // view
            case 2 -> 3;  // like
            case 3 -> 5;  // collect
            case 4 -> 2;  // share
            case 5 -> 4;  // comment
            default -> 1;
        };
    }
}
```

### 2.3 缓存模块

#### 2.3.1 多级缓存实现

```java
@Component
public class MultiLevelCache {

    @Resource
    private Cache<String, Object> localCache;  // Caffeine
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 获取缓存
     */
    public <T> T get(String key, Class<T> clazz) {
        // 一级缓存：本地缓存
        Object value = localCache.getIfPresent(key);
        if (value != null) {
            return clazz.cast(value);
        }

        // 二级缓存：Redis
        value = redisTemplate.opsForValue().get(key);
        if (value != null) {
            // 回填本地缓存
            localCache.put(key, value);
            return clazz.cast(value);
        }

        return null;
    }

    /**
     * 设置缓存
     */
    public void set(String key, Object value, long ttl, TimeUnit timeUnit) {
        // 本地缓存
        localCache.put(key, value);

        // Redis缓存
        redisTemplate.opsForValue().set(key, value, ttl, timeUnit);
    }

    /**
     * 删除缓存
     */
    public void delete(String key) {
        localCache.invalidate(key);
        redisTemplate.delete(key);
    }
}
```

#### 2.3.2 缓存预热

```java
@Component
public class CacheWarmup {

    @Resource
    private ArticleMapper articleMapper;
    @Resource
    private ImageMapper imageMapper;
    @Resource
    private VideoMapper videoMapper;
    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    /**
     * 预热热门内容
     */
    @Scheduled(cron = "0 0 2 * * ?")
    public void warmupHotContent() {
        // 预热热门文章
        List<Article> hotArticles = articleMapper.selectHotArticles(7, 100);
        warmupArticles(hotArticles);

        // 预热热门图片
        List<Image> hotImages = imageMapper.selectHotImages(7, 100);
        warmupImages(hotImages);

        // 预热热门视频
        List<Video> hotVideos = videoMapper.selectHotVideos(7, 100);
        warmupVideos(hotVideos);
    }

    private void warmupArticles(List<Article> articles) {
        String key = "hot_content:article:week";
        redisTemplate.delete(key);

        ZSetOperations<String, Object> zSet = redisTemplate.opsForZSet();
        articles.forEach(article -> {
            double score = calculateHotScore(article);
            zSet.add(key, "article:" + article.getId(), score);
        });

        redisTemplate.expire(key, 1, TimeUnit.HOURS);
    }

    private double calculateHotScore(Article article) {
        // 热度计算公式
        return article.getViewCount() * 0.5 +
               article.getLikeCount() * 0.3 +
               article.getCommentCount() * 0.2;
    }
}
```

---

## 三、并发与性能优化

### 3.1 虚拟线程应用

```java
@Configuration
public class VirtualThreadConfig {

    @Bean("virtualThreadExecutor")
    public ExecutorService virtualThreadExecutor() {
        return Executors.newVirtualThreadPerTaskExecutor();
    }
}

@Service
public class ParallelRecommendService {

    @Resource
    private ExecutorService virtualThreadExecutor;

    /**
     * 并行执行多个推荐策略
     */
    public RecommendResult recommendParallel(Long userId, String contentType, int limit) {
        List<CompletableFuture<List<RecommendItem>>> futures = List.of(
            CompletableFuture.supplyAsync(
                () -> recommendByContent(userId, contentType, limit),
                virtualThreadExecutor
            ),
            CompletableFuture.supplyAsync(
                () -> recommendByCF(userId, contentType, limit),
                virtualThreadExecutor
            ),
            CompletableFuture.supplyAsync(
                () -> recommendHot(contentType, limit),
                virtualThreadExecutor
            )
        );

        // 等待所有任务完成
        CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).join();

        // 合并结果
        List<RecommendItem> result = futures.stream()
            .flatMap(future -> future.join().stream())
            .collect(Collectors.toList());

        return mergeAndRank(result, limit);
    }
}
```

### 3.2 异步处理

```java
@Configuration
@EnableAsync
public class AsyncConfig {

    @Bean("taskExecutor")
    public Executor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(10);
        executor.setMaxPoolSize(20);
        executor.setQueueCapacity(200);
        executor.setThreadNamePrefix("async-task-");
        executor.setRejectedExecutionHandler(new ThreadPoolExecutor.CallerRunsPolicy());
        executor.initialize();
        return executor;
    }
}

@Service
public class AsyncBehaviorService {

    /**
     * 异步记录用户行为
     */
    @Async("taskExecutor")
    public void recordBehaviorAsync(UserBehavior behavior) {
        // 写入数据库
        userBehaviorMapper.insert(behavior);

        // 触发画像更新
        triggerProfileUpdate(behavior.getUserId());
    }

    /**
     * 异步更新用户画像
     */
    @Async("taskExecutor")
    public void updateUserProfileAsync(Long userId) {
        UserProfile profile = userProfileCalculator.calculate(userId);
        userProfileMapper.updateById(profile);

        // 清除缓存
        cacheService.deleteUserProfile(userId);
    }
}
```

### 3.3 数据库优化

#### 3.3.1 批量操作

```java
@Service
public class BatchOperationService {

    /**
     * 批量插入用户行为
     */
    @Transactional(rollbackFor = Exception.class)
    public void batchInsertBehaviors(List<UserBehavior> behaviors) {
        int batchSize = 1000;
        for (int i = 0; i < behaviors.size(); i += batchSize) {
            int end = Math.min(i + batchSize, behaviors.size());
            List<UserBehavior> batch = behaviors.subList(i, end);
            userBehaviorMapper.insertBatch(batch);
        }
    }

    /**
     * 批量查询
     */
    public Map<Long, Article> batchGetArticles(List<Long> ids) {
        List<Article> articles = articleMapper.selectBatchIds(ids);
        return articles.stream()
            .collect(Collectors.toMap(Article::getId, Function.identity()));
    }
}
```

#### 3.3.2 查询优化

```java
/**
 * 只查询需要的字段
 */
public List<ArticleDTO> getArticleList(Long categoryId, int pageNum, int pageSize) {
    Page<Article> page = new Page<>(pageNum, pageSize);
    LambdaQueryWrapper<Article> wrapper = new LambdaQueryWrapper<Article>()
        .select(Article::getId, Article::getTitle, Article::getSummary,
                Article::getCoverImage, Article::getViewCount, Article::getQualityScore)
        .eq(Article::getCategoryId, categoryId)
        .eq(Article::getStatus, 2)
        .orderByDesc(Article::getQualityScore);

    Page<Article> result = articleMapper.selectPage(page, wrapper);
    return result.getRecords().stream()
        .map(this::toDTO)
        .collect(Collectors.toList());
}
```

---

## 四、安全设计

### 4.1 认证与授权

```java
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf -> csrf.disable())
            .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(auth -> auth
                .requestMatchers("/api/public/**").permitAll()
                .requestMatchers("/api/recommend/**").authenticated()
                .requestMatchers("/api/content/publish").hasRole("CREATOR")
                .anyRequest().authenticated()
            );

        return http.build();
    }
}
```

### 4.2 参数校验

```java
@Data
public class RecommendRequest {

    @NotNull(message = "用户ID不能为空")
    private Long userId;

    @NotBlank(message = "内容类型不能为空")
    @Pattern(regexp = "^(article|image|video|all)$", message = "内容类型无效")
    private String contentType;

    @Min(value = 10, message = "推荐数量最小为10")
    @Max(value = 50, message = "推荐数量最大为50")
    private Integer limit = 20;
}
```

### 4.3 限流保护

```java
@Component
public class RateLimitInterceptor implements HandlerInterceptor {

    @Resource
    private RedisTemplate<String, Object> redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response,
                             Object handler) throws Exception {
        String userId = request.getHeader("X-User-Id");
        String uri = request.getRequestURI();

        String key = "rate_limit:" + userId + ":" + uri;
        Long count = redisTemplate.opsForValue().increment(key);

        if (count != null && count == 1) {
            redisTemplate.expire(key, 1, TimeUnit.MINUTES);
        }

        if (count != null && count > 100) {  // 每分钟100次
            response.setStatus(429);
            response.getWriter().write("Too many requests");
            return false;
        }

        return true;
    }
}
```

---

## 五、监控与日志

### 5.1 应用监控

```yaml
# application.yml
management:
  endpoints:
    web:
      exposure:
        include: health,info,metrics,prometheus,heapdump,threaddump
  metrics:
    export:
      prometheus:
        enabled: true
    tags:
      application: openrecommend
      environment: ${spring.profiles.active}
```

### 5.2 自定义指标

```java
@Component
public class RecommendMetrics {

    private final Counter recommendCounter;
    private final Timer recommendTimer;

    public RecommendMetrics(MeterRegistry registry) {
        recommendCounter = Counter.builder("recommend.requests")
            .description("Recommend request count")
            .tag("type", "personal")
            .register(registry);

        recommendTimer = Timer.builder("recommend.duration")
            .description("Recommend request duration")
            .tag("type", "personal")
            .register(registry);
    }

    public void recordRecommend(String type, long duration) {
        recommendCounter.increment();
        recommendTimer.record(duration, TimeUnit.MILLISECONDS);
    }
}
```

### 5.3 日志配置

```xml
<configuration>
    <appender name="FILE" class="ch.qos.logback.core.rolling.RollingFileAppender">
        <file>logs/openrecommend.log</file>
        <encoder>
            <pattern>%d{yyyy-MM-dd HH:mm:ss} [%thread] %-5level %logger{50} - %msg%n</pattern>
        </encoder>
        <rollingPolicy class="ch.qos.logback.core.rolling.TimeBasedRollingPolicy">
            <fileNamePattern>logs/openrecommend.%d{yyyy-MM-dd}.log</fileNamePattern>
            <maxHistory>30</maxHistory>
            <maxFileSize>100MB</maxFileSize>
        </rollingPolicy>
    </appender>

    <appender name="ASYNC_FILE" class="ch.qos.logback.classic.AsyncAppender">
        <appender-ref ref="FILE" />
        <queueSize>1000</queueSize>
        <discardingThreshold>0</discardingThreshold>
    </appender>

    <logger name="com.qoobot.openrecommend" level="DEBUG" additivity="false">
        <appender-ref ref="ASYNC_FILE" />
    </logger>

    <root level="INFO">
        <appender-ref ref="ASYNC_FILE" />
    </root>
</configuration>
```

---

## 六、部署技术

### 6.1 Docker化

**Dockerfile**:
```dockerfile
FROM eclipse-temurin:21-jre-alpine

LABEL maintainer="dev@qoobot.com"

WORKDIR /app

COPY target/openrecommend-1.0.0-SNAPSHOT.jar app.jar

RUN apk add --no-cache tzdata && \
    cp /usr/share/zoneinfo/Asia/Shanghai /etc/localtime && \
    echo "Asia/Shanghai" > /etc/timezone && \
    apk del tzdata

RUN mkdir -p /app/logs

EXPOSE 8080

ENV JAVA_OPTS="-XX:+UseZGC -Xms2g -Xmx2g -XX:MaxGCPauseMillis=200"

ENTRYPOINT ["sh", "-c", "java $JAVA_OPTS -jar app.jar"]
```

### 6.2 JVM优化

```bash
# 虚拟线程 + ZGC
java -XX:+UseVirtualThreads \
     -XX:+UseZGC \
     -Xms2g -Xmx2g \
     -XX:MaxGCPauseMillis=200 \
     -jar openrecommend.jar

# 生产环境JVM参数
JAVA_OPTS="-server \
           -XX:+UseZGC \
           -Xms4g -Xmx4g \
           -XX:MaxGCPauseMillis=100 \
           -XX:+UnlockExperimentalVMOptions \
           -XX:+UseStringDeduplication \
           -Djava.awt.headless=true"
```

---

## 七、技术风险与应对

| 风险 | 应对措施 |
|-----|---------|
| 并发性能瓶颈 | 虚拟线程 + 多级缓存 + 异步处理 |
| 数据库性能瓶颈 | 索引优化 + 读写分离 + 分库分表 |
| 缓存雪崩 | 缓存预热 + 多级缓存 + 限流降级 |
| 内存溢出 | JVM优化 + 监控告警 + 快速扩容 |
| 推荐算法效果差 | 多算法融合 + A/B测试 + 快速迭代 |

---

## 八、附录

### 8.1 核心技术依赖

```xml
<dependencies>
    <!-- Spring Boot -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

    <!-- MyBatis-Plus -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.5</version>
    </dependency>

    <!-- MySQL -->
    <dependency>
        <groupId>com.mysql</groupId>
        <artifactId>mysql-connector-j</artifactId>
        <version>8.4.0</version>
    </dependency>

    <!-- 工具库 -->
    <dependency>
        <groupId>cn.hutool</groupId>
        <artifactId>hutool-all</artifactId>
        <version>5.8.23</version>
    </dependency>

    <!-- Lombok -->
    <dependency>
        <groupId>org.projectlombok</groupId>
        <artifactId>lombok</artifactId>
        <optional>true</optional>
    </dependency>
</dependencies>
```

### 8.2 性能指标

| 指标 | 目标值 | 实现方案 |
|-----|-------|---------|
| QPS | 500+ | 虚拟线程 + 缓存 |
| P95响应时间 | <200ms | 多级缓存 + 并行处理 |
| P99响应时间 | <500ms | 优化算法 + 异步处理 |
| 内存占用 | <4GB | JVM优化 + 对象复用 |
| CPU占用 | <80% | 虚拟线程 + 负载均衡 |

### 8.3 变更记录

| 版本 | 日期 | 变更内容 | 变更人 |
|-----|------|---------|-------|
| 1.0.0 | 2026-02-15 | 初始版本 | - |
